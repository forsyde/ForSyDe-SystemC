---
layout: doxygen
title: API Documentation
---
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<div id="top">
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceForSyDe.html">ForSyDe</a></li><li class="navelem"><a class="el" href="namespaceForSyDe_1_1CT.html">CT</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ForSyDe::CT Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> MoC.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1add.html">add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a continuous-time process which adds its inputs.  <a href="classForSyDe_1_1CT_1_1add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1comb.html">comb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with one input and one output.  <a href="classForSyDe_1_1CT_1_1comb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1comb2.html">comb2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with two inputs and one output.  <a href="classForSyDe_1_1CT_1_1comb2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1combX.html">combX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with an array of inputs and one output.  <a href="classForSyDe_1_1CT_1_1combX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1constant.html">constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a constant source process.  <a href="classForSyDe_1_1CT_1_1constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1cosine.html">cosine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a coasine source.  <a href="classForSyDe_1_1CT_1_1cosine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1CT2CT.html">CT2CT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1CT_1_1CT2CT.html" title="The CT2CT signal used to inter-connect CT processes. ">CT2CT</a> signal used to inter-connect <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> processes.  <a href="classForSyDe_1_1CT_1_1CT2CT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1CT__in.html">CT_in</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1CT_1_1CT__in.html" title="The CT_in port is used for input ports of CT processes. ">CT_in</a> port is used for input ports of <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> processes.  <a href="classForSyDe_1_1CT_1_1CT__in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1CT__out.html">CT_out</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1CT_1_1CT__out.html" title="The CT_out port is used for output ports of CT processes. ">CT_out</a> port is used for output ports of <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> processes.  <a href="classForSyDe_1_1CT_1_1CT__out.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1delay.html">delay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a delay element.  <a href="classForSyDe_1_1CT_1_1delay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1fanout.html">fanout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a fan-out process with one input and one output.  <a href="classForSyDe_1_1CT_1_1fanout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1fmi2cswrap.html">fmi2cswrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a co-simulation FMU wrapper with one input and one output.  <a href="classForSyDe_1_1CT_1_1fmi2cswrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1mul.html">mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a continuous-time process which multiplies its inputs.  <a href="classForSyDe_1_1CT_1_1mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1scale.html">scale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a continuous-time process which scales the input.  <a href="classForSyDe_1_1CT_1_1scale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1shift.html">shift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a shift element.  <a href="classForSyDe_1_1CT_1_1shift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1sine.html">sine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a coasine source.  <a href="classForSyDe_1_1CT_1_1sine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a sink process.  <a href="classForSyDe_1_1CT_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1source.html">source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a source process.  <a href="classForSyDe_1_1CT_1_1source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1square.html">square</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a square source.  <a href="classForSyDe_1_1CT_1_1square.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1sub.html">sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a continuous-time process which subtracts its inputs.  <a href="classForSyDe_1_1CT_1_1sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1CT_1_1traceSig.html">traceSig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a trace process.  <a href="classForSyDe_1_1CT_1_1traceSig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad5e3a6fbc1cba55540d501163dea9547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5e3a6fbc1cba55540d501163dea9547"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ad5e3a6fbc1cba55540d501163dea9547">signal</a> = <a class="el" href="classForSyDe_1_1CT_1_1CT2CT.html">CT2CT</a></td></tr>
<tr class="memdesc:ad5e3a6fbc1cba55540d501163dea9547"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceForSyDe_1_1CT.html#ad5e3a6fbc1cba55540d501163dea9547" title="The CT::signal is an alias for CT::CT2CT. ">CT::signal</a> is an alias for <a class="el" href="classForSyDe_1_1CT_1_1CT2CT.html" title="The CT2CT signal used to inter-connect CT processes. ">CT::CT2CT</a>. <br /></td></tr>
<tr class="separator:ad5e3a6fbc1cba55540d501163dea9547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3f6886d9a453b94cdf3c70051128a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f3f6886d9a453b94cdf3c70051128a4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a8f3f6886d9a453b94cdf3c70051128a4">in_port</a> = <a class="el" href="classForSyDe_1_1CT_1_1CT__in.html">CT_in</a></td></tr>
<tr class="memdesc:a8f3f6886d9a453b94cdf3c70051128a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceForSyDe_1_1CT.html#a8f3f6886d9a453b94cdf3c70051128a4" title="The CT::in_port is an alias for CT::CT_in. ">CT::in_port</a> is an alias for <a class="el" href="classForSyDe_1_1CT_1_1CT__in.html" title="The CT_in port is used for input ports of CT processes. ">CT::CT_in</a>. <br /></td></tr>
<tr class="separator:a8f3f6886d9a453b94cdf3c70051128a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b3e38fb7b908aa40729d6166f81b0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2b3e38fb7b908aa40729d6166f81b0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#aa2b3e38fb7b908aa40729d6166f81b0c">out_port</a> = <a class="el" href="classForSyDe_1_1CT_1_1CT__out.html">CT_out</a></td></tr>
<tr class="memdesc:aa2b3e38fb7b908aa40729d6166f81b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceForSyDe_1_1CT.html#aa2b3e38fb7b908aa40729d6166f81b0c" title="The CT::out_port is an alias for CT::CT_out. ">CT::out_port</a> is an alias for <a class="el" href="classForSyDe_1_1CT_1_1CT__out.html" title="The CT_out port is used for output ports of CT processes. ">CT::CT_out</a>. <br /></td></tr>
<tr class="separator:aa2b3e38fb7b908aa40729d6166f81b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78677884043556180cf61c89024d4d01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78677884043556180cf61c89024d4d01"></a>
typedef <a class="el" href="classForSyDe_1_1process.html">ForSyDe::process</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a78677884043556180cf61c89024d4d01">ct_process</a></td></tr>
<tr class="memdesc:a78677884043556180cf61c89024d4d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract semantics of a process in the <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> MoC. <br /></td></tr>
<tr class="separator:a78677884043556180cf61c89024d4d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2c2c9b7a6919c2f55adfeac46917ed1"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:ad2c2c9b7a6919c2f55adfeac46917ed1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1comb.html">comb</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ad2c2c9b7a6919c2f55adfeac46917ed1">make_comb</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1CT_1_1comb.html#a38e05fab4af90b41355fef9972711332">comb::functype</a> _func, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:ad2c2c9b7a6919c2f55adfeac46917ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a comb process.  <a href="#ad2c2c9b7a6919c2f55adfeac46917ed1">More...</a><br /></td></tr>
<tr class="separator:ad2c2c9b7a6919c2f55adfeac46917ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c56dfcf903c74e7277e59ed48e15c"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If , class I2If &gt; </td></tr>
<tr class="memitem:a2b2c56dfcf903c74e7277e59ed48e15c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1comb2.html">comb2</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a2b2c56dfcf903c74e7277e59ed48e15c">make_comb2</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1CT_1_1comb2.html#aaf851f6e4efa3d9573b036f878712cf2">comb2::functype</a> _func, OIf &amp;outS, I1If &amp;inp1S, I2If &amp;inp2S)</td></tr>
<tr class="memdesc:a2b2c56dfcf903c74e7277e59ed48e15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1CT_1_1comb2.html" title="Process constructor for a combinational process with two inputs and one output. ">comb2</a> process.  <a href="#a2b2c56dfcf903c74e7277e59ed48e15c">More...</a><br /></td></tr>
<tr class="separator:a2b2c56dfcf903c74e7277e59ed48e15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86279c63f970894a79a293f4cd2b8711"><td class="memTemplParams" colspan="2">template&lt;class OIf , class IIf , std::size_t N&gt; </td></tr>
<tr class="memitem:a86279c63f970894a79a293f4cd2b8711"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1combX.html">combX</a>&lt; N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a86279c63f970894a79a293f4cd2b8711">make_combX</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1CT_1_1combX.html">combX</a>&lt; N &gt;::functype _func, OIf &amp;outS, std::array&lt; IIf, N &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a86279c63f970894a79a293f4cd2b8711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1CT_1_1combX.html" title="Process constructor for a combinational process with an array of inputs and one output. ">combX</a> process.  <a href="#a86279c63f970894a79a293f4cd2b8711">More...</a><br /></td></tr>
<tr class="separator:a86279c63f970894a79a293f4cd2b8711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dec6a43918d7ee39551e67c8f684c85"><td class="memTemplParams" colspan="2">template&lt;class IIf , class OIf &gt; </td></tr>
<tr class="memitem:a0dec6a43918d7ee39551e67c8f684c85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1delay.html">delay</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a0dec6a43918d7ee39551e67c8f684c85">make_delay</a> (std::string pName, sc_time delay_time, OIf &amp;outS, IIf &amp;inpS)</td></tr>
<tr class="memdesc:a0dec6a43918d7ee39551e67c8f684c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a delay process.  <a href="#a0dec6a43918d7ee39551e67c8f684c85">More...</a><br /></td></tr>
<tr class="separator:a0dec6a43918d7ee39551e67c8f684c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f9d1e90435c3636e428a45d931024"><td class="memTemplParams" colspan="2">template&lt;class IIf , class OIf &gt; </td></tr>
<tr class="memitem:a854f9d1e90435c3636e428a45d931024"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1shift.html">shift</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a854f9d1e90435c3636e428a45d931024">make_shift</a> (std::string pName, sc_time delay_time, OIf &amp;outS, IIf &amp;inpS)</td></tr>
<tr class="memdesc:a854f9d1e90435c3636e428a45d931024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a shift process.  <a href="#a854f9d1e90435c3636e428a45d931024">More...</a><br /></td></tr>
<tr class="separator:a854f9d1e90435c3636e428a45d931024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb7ee268d6800d3bf8dc15c3cd44946"><td class="memTemplParams" colspan="2">template&lt;class OIf &gt; </td></tr>
<tr class="memitem:a9eb7ee268d6800d3bf8dc15c3cd44946"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1constant.html">constant</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a9eb7ee268d6800d3bf8dc15c3cd44946">make_constant</a> (std::string pName, <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> init_val, sc_time end_time, OIf &amp;outS)</td></tr>
<tr class="memdesc:a9eb7ee268d6800d3bf8dc15c3cd44946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a constant source process.  <a href="#a9eb7ee268d6800d3bf8dc15c3cd44946">More...</a><br /></td></tr>
<tr class="separator:a9eb7ee268d6800d3bf8dc15c3cd44946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4237cf6421de5a9023f21fc9a0db0c"><td class="memTemplParams" colspan="2">template&lt;class OIf &gt; </td></tr>
<tr class="memitem:a2a4237cf6421de5a9023f21fc9a0db0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1source.html">source</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a2a4237cf6421de5a9023f21fc9a0db0c">make_source</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1CT_1_1source.html#a9775f508581b108de6b003dcb27309e3">source::functype</a> _func, const sc_time &amp;end_time, OIf &amp;outS)</td></tr>
<tr class="memdesc:a2a4237cf6421de5a9023f21fc9a0db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a source process.  <a href="#a2a4237cf6421de5a9023f21fc9a0db0c">More...</a><br /></td></tr>
<tr class="separator:a2a4237cf6421de5a9023f21fc9a0db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f128841c215991f8dc9c69264fa732"><td class="memTemplParams" colspan="2">template&lt;class IIf &gt; </td></tr>
<tr class="memitem:a00f128841c215991f8dc9c69264fa732"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1sink.html">sink</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a00f128841c215991f8dc9c69264fa732">make_sink</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1CT_1_1sink.html#a6e7dfd8a4f7e9b913e64916e151fa828">sink::functype</a> _func, sc_time sampling_period, IIf &amp;inS)</td></tr>
<tr class="memdesc:a00f128841c215991f8dc9c69264fa732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sink process.  <a href="#a00f128841c215991f8dc9c69264fa732">More...</a><br /></td></tr>
<tr class="separator:a00f128841c215991f8dc9c69264fa732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade35d67f9e2f99b20ae540b48ebf41d0"><td class="memTemplParams" colspan="2">template&lt;class IIf &gt; </td></tr>
<tr class="memitem:ade35d67f9e2f99b20ae540b48ebf41d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1traceSig.html">traceSig</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ade35d67f9e2f99b20ae540b48ebf41d0">make_traceSig</a> (std::string pName, sc_time sampling_period, IIf &amp;inpS)</td></tr>
<tr class="memdesc:ade35d67f9e2f99b20ae540b48ebf41d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1CT_1_1traceSig.html" title="Process constructor for a trace process. ">traceSig</a> process.  <a href="#ade35d67f9e2f99b20ae540b48ebf41d0">More...</a><br /></td></tr>
<tr class="separator:ade35d67f9e2f99b20ae540b48ebf41d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72997e247ef5e7afd8d4cc791e4fdbb8"><td class="memTemplParams" colspan="2">template&lt;class IIf , class OIf &gt; </td></tr>
<tr class="memitem:a72997e247ef5e7afd8d4cc791e4fdbb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1fanout.html">fanout</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a72997e247ef5e7afd8d4cc791e4fdbb8">make_fanout</a> (std::string pName, OIf &amp;outS, IIf &amp;inpS)</td></tr>
<tr class="memdesc:a72997e247ef5e7afd8d4cc791e4fdbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a fanout process.  <a href="#a72997e247ef5e7afd8d4cc791e4fdbb8">More...</a><br /></td></tr>
<tr class="separator:a72997e247ef5e7afd8d4cc791e4fdbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922cc2d8ec91cd55a9a3057484be9bee"><td class="memTemplParams" colspan="2">template&lt;class OIf &gt; </td></tr>
<tr class="memitem:a922cc2d8ec91cd55a9a3057484be9bee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1sine.html">sine</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a922cc2d8ec91cd55a9a3057484be9bee">make_sine</a> (std::string pName, const sc_time &amp;endT, const sc_time &amp;period, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;ampl, OIf &amp;outS)</td></tr>
<tr class="memdesc:a922cc2d8ec91cd55a9a3057484be9bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sine source process.  <a href="#a922cc2d8ec91cd55a9a3057484be9bee">More...</a><br /></td></tr>
<tr class="separator:a922cc2d8ec91cd55a9a3057484be9bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365ce64b376d180cc888e2d83b66a222"><td class="memTemplParams" colspan="2">template&lt;class OIf &gt; </td></tr>
<tr class="memitem:a365ce64b376d180cc888e2d83b66a222"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1cosine.html">cosine</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a365ce64b376d180cc888e2d83b66a222">make_cosine</a> (std::string pName, const sc_time &amp;endT, const sc_time &amp;period, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;ampl, OIf &amp;outS)</td></tr>
<tr class="memdesc:a365ce64b376d180cc888e2d83b66a222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a cosine source process.  <a href="#a365ce64b376d180cc888e2d83b66a222">More...</a><br /></td></tr>
<tr class="separator:a365ce64b376d180cc888e2d83b66a222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15fa0ebe904f6f636800e8399fc0493"><td class="memTemplParams" colspan="2">template&lt;class OIf &gt; </td></tr>
<tr class="memitem:ae15fa0ebe904f6f636800e8399fc0493"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1square.html">square</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ae15fa0ebe904f6f636800e8399fc0493">make_square</a> (std::string pName, const sc_time &amp;endT, const sc_time &amp;period, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;highS, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;lowS, const double &amp;dutyCycle, OIf &amp;outS)</td></tr>
<tr class="memdesc:ae15fa0ebe904f6f636800e8399fc0493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a square source process.  <a href="#ae15fa0ebe904f6f636800e8399fc0493">More...</a><br /></td></tr>
<tr class="separator:ae15fa0ebe904f6f636800e8399fc0493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dcb1710e2e9f0dbf8d6f10fab3bfe1"><td class="memTemplParams" colspan="2">template&lt;class OIf , class IIf &gt; </td></tr>
<tr class="memitem:a84dcb1710e2e9f0dbf8d6f10fab3bfe1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1scale.html">scale</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a84dcb1710e2e9f0dbf8d6f10fab3bfe1">make_scale</a> (std::string pName, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;scaling_factor, OIf &amp;outS, IIf &amp;inpS)</td></tr>
<tr class="memdesc:a84dcb1710e2e9f0dbf8d6f10fab3bfe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a scale process.  <a href="#a84dcb1710e2e9f0dbf8d6f10fab3bfe1">More...</a><br /></td></tr>
<tr class="separator:a84dcb1710e2e9f0dbf8d6f10fab3bfe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c4ec8e1e86f6e2b1ae53e40cc48cfc"><td class="memTemplParams" colspan="2">template&lt;class OIf , class IIf1 , class IIf2 &gt; </td></tr>
<tr class="memitem:ab4c4ec8e1e86f6e2b1ae53e40cc48cfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1add.html">add</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ab4c4ec8e1e86f6e2b1ae53e40cc48cfc">make_add</a> (std::string pName, OIf &amp;outS, IIf1 &amp;inp1S, IIf2 &amp;inp2S)</td></tr>
<tr class="memdesc:ab4c4ec8e1e86f6e2b1ae53e40cc48cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct an add process.  <a href="#ab4c4ec8e1e86f6e2b1ae53e40cc48cfc">More...</a><br /></td></tr>
<tr class="separator:ab4c4ec8e1e86f6e2b1ae53e40cc48cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec660fcc85d989dfa5129544982f4b7a"><td class="memTemplParams" colspan="2">template&lt;class OIf , class IIf1 , class IIf2 &gt; </td></tr>
<tr class="memitem:aec660fcc85d989dfa5129544982f4b7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1sub.html">sub</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#aec660fcc85d989dfa5129544982f4b7a">make_sub</a> (std::string pName, OIf &amp;outS, IIf1 &amp;inp1S, IIf2 &amp;inp2S)</td></tr>
<tr class="memdesc:aec660fcc85d989dfa5129544982f4b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sub process.  <a href="#aec660fcc85d989dfa5129544982f4b7a">More...</a><br /></td></tr>
<tr class="separator:aec660fcc85d989dfa5129544982f4b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48852a854756a13d4deaae72dc958a0c"><td class="memTemplParams" colspan="2">template&lt;class OIf , class IIf1 , class IIf2 &gt; </td></tr>
<tr class="memitem:a48852a854756a13d4deaae72dc958a0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1mul.html">mul</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a48852a854756a13d4deaae72dc958a0c">make_mul</a> (std::string pName, OIf &amp;outS, IIf1 &amp;inp1S, IIf2 &amp;inp2S)</td></tr>
<tr class="memdesc:a48852a854756a13d4deaae72dc958a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a mul process.  <a href="#a48852a854756a13d4deaae72dc958a0c">More...</a><br /></td></tr>
<tr class="separator:a48852a854756a13d4deaae72dc958a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0c19fffed68dbba938de97f7585ed8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a2e0c19fffed68dbba938de97f7585ed8">SC_MODULE</a> (gaussian)</td></tr>
<tr class="memdesc:a2e0c19fffed68dbba938de97f7585ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a Gaussian randome wave generator.  <a href="#a2e0c19fffed68dbba938de97f7585ed8">More...</a><br /></td></tr>
<tr class="separator:a2e0c19fffed68dbba938de97f7585ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9f2f126dfaa13097bc6e6a9aabc88e"><td class="memTemplParams" colspan="2">template&lt;class OIf &gt; </td></tr>
<tr class="memitem:a1d9f2f126dfaa13097bc6e6a9aabc88e"><td class="memTemplItemLeft" align="right" valign="top">gaussian *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a1d9f2f126dfaa13097bc6e6a9aabc88e">make_gaussian</a> (std::string pName, const double &amp;gaussVar, const double &amp;gaussMean, const sc_time sample_period, OIf &amp;outS)</td></tr>
<tr class="memdesc:a1d9f2f126dfaa13097bc6e6a9aabc88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a gaussian process.  <a href="#a1d9f2f126dfaa13097bc6e6a9aabc88e">More...</a><br /></td></tr>
<tr class="separator:a1d9f2f126dfaa13097bc6e6a9aabc88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c795a68ddb6e8ad8f94fafad983831"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ae0c795a68ddb6e8ad8f94fafad983831">SC_MODULE</a> (filter)</td></tr>
<tr class="memdesc:ae0c795a68ddb6e8ad8f94fafad983831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for implementing a linear filter.  <a href="#ae0c795a68ddb6e8ad8f94fafad983831">More...</a><br /></td></tr>
<tr class="separator:ae0c795a68ddb6e8ad8f94fafad983831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0643ebd7a14c1dcf0ac5eab01d6c3"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:a13e0643ebd7a14c1dcf0ac5eab01d6c3"><td class="memTemplItemLeft" align="right" valign="top">filter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a13e0643ebd7a14c1dcf0ac5eab01d6c3">make_filter</a> (std::string pName, const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt; numerators, const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt; denominators, const sc_time sample_period, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:a13e0643ebd7a14c1dcf0ac5eab01d6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a linear process.  <a href="#a13e0643ebd7a14c1dcf0ac5eab01d6c3">More...</a><br /></td></tr>
<tr class="separator:a13e0643ebd7a14c1dcf0ac5eab01d6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bb48604a1ffbabf7d8b1642c953e2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#aa2bb48604a1ffbabf7d8b1642c953e2c">SC_MODULE</a> (filterf)</td></tr>
<tr class="memdesc:aa2bb48604a1ffbabf7d8b1642c953e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for implementing a linear filter with fixed step.  <a href="#aa2bb48604a1ffbabf7d8b1642c953e2c">More...</a><br /></td></tr>
<tr class="separator:aa2bb48604a1ffbabf7d8b1642c953e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0c1da8303241df3b1f0721f13e06b0"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:adb0c1da8303241df3b1f0721f13e06b0"><td class="memTemplItemLeft" align="right" valign="top">filterf *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#adb0c1da8303241df3b1f0721f13e06b0">make_filterf</a> (std::string pName, const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt; numerators, const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt; denominators, const sc_time sample_period, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:adb0c1da8303241df3b1f0721f13e06b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a linear process with fixed step size.  <a href="#adb0c1da8303241df3b1f0721f13e06b0">More...</a><br /></td></tr>
<tr class="separator:adb0c1da8303241df3b1f0721f13e06b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4b8407f4e55df141daf4edb70486b6"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:aeb4b8407f4e55df141daf4edb70486b6"><td class="memTemplItemLeft" align="right" valign="top">filter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#aeb4b8407f4e55df141daf4edb70486b6">make_integrator</a> (std::string pName, const sc_time sample_period, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:aeb4b8407f4e55df141daf4edb70486b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct an integrator.  <a href="#aeb4b8407f4e55df141daf4edb70486b6">More...</a><br /></td></tr>
<tr class="separator:aeb4b8407f4e55df141daf4edb70486b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e802b228b05ea2816eba60ee2f8d824"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:a5e802b228b05ea2816eba60ee2f8d824"><td class="memTemplItemLeft" align="right" valign="top">filterf *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a5e802b228b05ea2816eba60ee2f8d824">make_integratorf</a> (std::string pName, const sc_time sample_period, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:a5e802b228b05ea2816eba60ee2f8d824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct an integrator with fixed step size.  <a href="#a5e802b228b05ea2816eba60ee2f8d824">More...</a><br /></td></tr>
<tr class="separator:a5e802b228b05ea2816eba60ee2f8d824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ddf4355c99fc6503d4c0482951fa8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#ac2ddf4355c99fc6503d4c0482951fa8c">SC_MODULE</a> (pif)</td></tr>
<tr class="memdesc:ac2ddf4355c99fc6503d4c0482951fa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for implementing a PI controller with fixed step.  <a href="#ac2ddf4355c99fc6503d4c0482951fa8c">More...</a><br /></td></tr>
<tr class="separator:ac2ddf4355c99fc6503d4c0482951fa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b5461382a84a72678beda914a0b93"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:a578b5461382a84a72678beda914a0b93"><td class="memTemplItemLeft" align="right" valign="top">pif *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#a578b5461382a84a72678beda914a0b93">make_pif</a> (std::string pName, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;kp, const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;ki, const sc_time sample_period, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:a578b5461382a84a72678beda914a0b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a PI controller with fixed step size.  <a href="#a578b5461382a84a72678beda914a0b93">More...</a><br /></td></tr>
<tr class="separator:a578b5461382a84a72678beda914a0b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3931b500a243ea4b9e98ada8906941"><td class="memTemplParams" colspan="2">template&lt;class OIf , class I1If &gt; </td></tr>
<tr class="memitem:aac3931b500a243ea4b9e98ada8906941"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1CT_1_1fmi2cswrap.html">fmi2cswrap</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1CT.html#aac3931b500a243ea4b9e98ada8906941">make_fmi2cswrap</a> (const std::string &amp;pName, const std::string &amp;fmu_file, const unsigned &amp;input_index, const unsigned &amp;output_index, const sc_time &amp;sample_period, OIf &amp;outS, I1If &amp;inp1S)</td></tr>
<tr class="memdesc:aac3931b500a243ea4b9e98ada8906941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a pipewrap process.  <a href="#aac3931b500a243ea4b9e98ada8906941">More...</a><br /></td></tr>
<tr class="separator:aac3931b500a243ea4b9e98ada8906941"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> MoC. </p>
<p>This namespace includes constructs used for building models in the continuous-time MoC. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab4c4ec8e1e86f6e2b1ae53e40cc48cfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class IIf1 , class IIf2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1add.html">add</a>* ForSyDe::CT::make_add </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf1 &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf2 &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct an add process. </p>
<p>This function is used to construct an adder and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ad2c2c9b7a6919c2f55adfeac46917ed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1comb.html">comb</a>* ForSyDe::CT::make_comb </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1CT_1_1comb.html#a38e05fab4af90b41355fef9972711332">comb::functype</a>&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a comb process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a2b2c56dfcf903c74e7277e59ed48e15c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If , class I2If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1comb2.html">comb2</a>* ForSyDe::CT::make_comb2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1CT_1_1comb2.html#aaf851f6e4efa3d9573b036f878712cf2">comb2::functype</a>&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1CT_1_1comb2.html" title="Process constructor for a combinational process with two inputs and one output. ">comb2</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a86279c63f970894a79a293f4cd2b8711"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class IIf , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1combX.html">combX</a>&lt;N&gt;* ForSyDe::CT::make_combX </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1CT_1_1combX.html">combX</a>&lt; N &gt;::functype&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IIf, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1CT_1_1combX.html" title="Process constructor for a combinational process with an array of inputs and one output. ">combX</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a9eb7ee268d6800d3bf8dc15c3cd44946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1constant.html">constant</a>* ForSyDe::CT::make_constant </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a>&#160;</td>
          <td class="paramname"><em>init_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_time&#160;</td>
          <td class="paramname"><em>end_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a constant source process. </p>
<p>This function is used to construct a constant (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a365ce64b376d180cc888e2d83b66a222"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1cosine.html">cosine</a>* ForSyDe::CT::make_cosine </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>endT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>ampl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a cosine source process. </p>
<p>This function is used to construct a cosine source and connect its output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endT</td><td>The end time of the generated signal </td></tr>
    <tr><td class="paramname">period</td><td>The signal period (1/f) </td></tr>
    <tr><td class="paramname">ampl</td><td>The signal amplitude </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dec6a43918d7ee39551e67c8f684c85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IIf , class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1delay.html">delay</a>* ForSyDe::CT::make_delay </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_time&#160;</td>
          <td class="paramname"><em>delay_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a delay process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a72997e247ef5e7afd8d4cc791e4fdbb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IIf , class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1fanout.html">fanout</a>* ForSyDe::CT::make_fanout </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a fanout process. </p>
<p>This function is used to construct a fanout process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a13e0643ebd7a14c1dcf0ac5eab01d6c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">filter* ForSyDe::CT::make_filter </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt;&#160;</td>
          <td class="paramname"><em>numerators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt;&#160;</td>
          <td class="paramname"><em>denominators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a linear process. </p>
<p>This function is used to construct a <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> filter and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numerators</td><td>Numerator constants </td></tr>
    <tr><td class="paramname">denominators</td><td>Denominator constants </td></tr>
    <tr><td class="paramname">sample_period</td><td>sampling period </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb0c1da8303241df3b1f0721f13e06b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">filterf* ForSyDe::CT::make_filterf </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt;&#160;</td>
          <td class="paramname"><em>numerators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &gt;&#160;</td>
          <td class="paramname"><em>denominators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a linear process with fixed step size. </p>
<p>This function is used to construct a <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> filter and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numerators</td><td>Numerator constants </td></tr>
    <tr><td class="paramname">denominators</td><td>Denominator constants </td></tr>
    <tr><td class="paramname">sample_period</td><td>sampling period </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac3931b500a243ea4b9e98ada8906941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1fmi2cswrap.html">fmi2cswrap</a>* ForSyDe::CT::make_fmi2cswrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fmu_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>input_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>output_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a pipewrap process. </p>
<p>This function is used to construct a pipe wrapper process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a1d9f2f126dfaa13097bc6e6a9aabc88e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gaussian* ForSyDe::CT::make_gaussian </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>gaussVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>gaussMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a gaussian process. </p>
<p>This function is used to construct a gaussian signal generator and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussVar</td><td>The variance </td></tr>
    <tr><td class="paramname">gaussMean</td><td>The mean value </td></tr>
    <tr><td class="paramname">sample_period</td><td>sampling period </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb4b8407f4e55df141daf4edb70486b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">filter* ForSyDe::CT::make_integrator </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct an integrator. </p>
<p>This function is used to construct a <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> integrator and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_period</td><td>sampling period </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e802b228b05ea2816eba60ee2f8d824"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">filterf* ForSyDe::CT::make_integratorf </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct an integrator with fixed step size. </p>
<p>This function is used to construct a <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> integrator with fixed step size and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_period</td><td>sampling period </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48852a854756a13d4deaae72dc958a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class IIf1 , class IIf2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1mul.html">mul</a>* ForSyDe::CT::make_mul </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf1 &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf2 &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a mul process. </p>
<p>This function is used to construct a multiplier and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a578b5461382a84a72678beda914a0b93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class I1If &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pif* ForSyDe::CT::make_pif </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>kp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time&#160;</td>
          <td class="paramname"><em>sample_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a PI controller with fixed step size. </p>
<p>This function is used to construct a PI controller with fixed step size and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a84dcb1710e2e9f0dbf8d6f10fab3bfe1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class IIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1scale.html">scale</a>* ForSyDe::CT::make_scale </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>scaling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a scale process. </p>
<p>This function is used to construct a scale source and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaling_factor</td><td>The scaling factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a854f9d1e90435c3636e428a45d931024"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IIf , class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1shift.html">shift</a>* ForSyDe::CT::make_shift </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_time&#160;</td>
          <td class="paramname"><em>delay_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a shift process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a922cc2d8ec91cd55a9a3057484be9bee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1sine.html">sine</a>* ForSyDe::CT::make_sine </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>endT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>ampl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sine source process. </p>
<p>This function is used to construct a sine source and connect its output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endT</td><td>The end time of the generated signal </td></tr>
    <tr><td class="paramname">period</td><td>The signal period (1/f) </td></tr>
    <tr><td class="paramname">ampl</td><td>The signal amplitude </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00f128841c215991f8dc9c69264fa732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1sink.html">sink</a>* ForSyDe::CT::make_sink </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1CT_1_1sink.html#a6e7dfd8a4f7e9b913e64916e151fa828">sink::functype</a>&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_time&#160;</td>
          <td class="paramname"><em>sampling_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf &amp;&#160;</td>
          <td class="paramname"><em>inS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sink process. </p>
<p>This function is used to construct a sink (SystemC module) and connect its input signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a2a4237cf6421de5a9023f21fc9a0db0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1source.html">source</a>* ForSyDe::CT::make_source </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1CT_1_1source.html#a9775f508581b108de6b003dcb27309e3">source::functype</a>&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>end_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a source process. </p>
<p>This function is used to construct a source (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ae15fa0ebe904f6f636800e8399fc0493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1square.html">square</a>* ForSyDe::CT::make_square </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>endT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sc_time &amp;&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>highS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceForSyDe.html#a472dae472f503e1e79a8813f31e2a5d1">CTTYPE</a> &amp;&#160;</td>
          <td class="paramname"><em>lowS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dutyCycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a square source process. </p>
<p>This function is used to construct a square source and connect its output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endT</td><td>The end time of the generated signal </td></tr>
    <tr><td class="paramname">period</td><td>The signal period (1/f) </td></tr>
    <tr><td class="paramname">highS</td><td>The signal high swing </td></tr>
    <tr><td class="paramname">lowS</td><td>The signal low swing </td></tr>
    <tr><td class="paramname">dutyCycle</td><td>The duty cycle (0 to 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec660fcc85d989dfa5129544982f4b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OIf , class IIf1 , class IIf2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1sub.html">sub</a>* ForSyDe::CT::make_sub </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf1 &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf2 &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sub process. </p>
<p>This function is used to construct a subtractor and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ade35d67f9e2f99b20ae540b48ebf41d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IIf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1CT_1_1traceSig.html">traceSig</a>* ForSyDe::CT::make_traceSig </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sc_time&#160;</td>
          <td class="paramname"><em>sampling_period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1CT_1_1traceSig.html" title="Process constructor for a trace process. ">traceSig</a> process. </p>
<p>This function is used to construct a <a class="el" href="classForSyDe_1_1CT_1_1traceSig.html" title="Process constructor for a trace process. ">traceSig</a> (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a2e0c19fffed68dbba938de97f7585ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForSyDe::CT::SC_MODULE </td>
          <td>(</td>
          <td class="paramtype">gaussian&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process constructor for a Gaussian randome wave generator. </p>
<p>This class is used to create a continuous-time signal source which produces a Random signal based on the Gaussian distribution </p>
<p>&lt; port for the output channel</p>
<p>The constructor requires the module name and the generator parameters</p>
<p>&lt; Process name</p>
<p>&lt; The variance</p>
<p>&lt; The mean value</p>
<p>&lt; sampling period </p>

</div>
</div>
<a class="anchor" id="ae0c795a68ddb6e8ad8f94fafad983831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForSyDe::CT::SC_MODULE </td>
          <td>(</td>
          <td class="paramtype">filter&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process constructor for implementing a linear filter. </p>
<p>This class is used to build a process which implements a linear in the <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> MoC filter based on the numerator and denominator constants. It internally uses a <a class="el" href="namespaceForSyDe_1_1DDE.html" title="The namespace for DDE MoC. ">DDE</a> filter together with <a class="el" href="classForSyDe_1_1CT2DDE.html" title="Process constructor for a CT2DDE MoC interface. ">CT2DDE</a> and <a class="el" href="classForSyDe_1_1DDE2CT.html" title="Process constructor for a DDE2CT MoC interfaces. ">DDE2CT</a> MoC interfaces. </p>
<p>&lt; port for the input channel</p>
<p>&lt; port for the output channel;</p>
<p>The constructor requires the module name and the filter parameters</p>
<p>&lt; Process name</p>
<p>&lt; Numerator constants</p>
<p>&lt; Denominator constants</p>
<p>&lt; sampling period</p>
<p>&lt; Minimum time step</p>
<p>&lt; Tolerated error </p>

</div>
</div>
<a class="anchor" id="aa2bb48604a1ffbabf7d8b1642c953e2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForSyDe::CT::SC_MODULE </td>
          <td>(</td>
          <td class="paramtype">filterf&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process constructor for implementing a linear filter with fixed step. </p>
<p>This class is used to build a process which implements a linear in the <a class="el" href="namespaceForSyDe_1_1CT.html" title="The namespace for CT MoC. ">CT</a> MoC filter with fixed step based on the numerator and denominator constants. It internally uses a <a class="el" href="namespaceForSyDe_1_1DDE.html" title="The namespace for DDE MoC. ">DDE</a> filter together with <a class="el" href="classForSyDe_1_1CT2DDEf.html" title="Process constructor for a CT2DDEf MoC interface. ">CT2DDEf</a> and <a class="el" href="classForSyDe_1_1DDE2CT.html" title="Process constructor for a DDE2CT MoC interfaces. ">DDE2CT</a> MoC interfaces. </p>
<p>&lt; port for the input channel</p>
<p>&lt; port for the output channel;</p>
<p>The constructor requires the module name and the filter parameters</p>
<p>&lt; Process name</p>
<p>&lt; Numerator constants</p>
<p>&lt; Denominator constants</p>
<p>&lt; sampling period </p>

</div>
</div>
<a class="anchor" id="ac2ddf4355c99fc6503d4c0482951fa8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForSyDe::CT::SC_MODULE </td>
          <td>(</td>
          <td class="paramtype">pif&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process constructor for implementing a PI controller with fixed step. </p>
<p>This class is used to build a PI controller with fixed step size based on the proportional and integral gain parameters. It internally uses a scale, an integrator and an adder. </p>
<p>&lt; port for the input channel</p>
<p>&lt; port for the output channel;</p>
<p>The constructor requires the module name and the gains</p>
<p>&lt; Process name</p>
<p>&lt; Numerator constants</p>
<p>&lt; Denominator constants</p>
<p>&lt; sampling period </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
Doxygen
</a> 1.8.11
</small></address>
</body>
</html>
