---
layout: doxygen
title: API Documentation
---
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<div id="top">
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceForSyDe.html">ForSyDe</a></li><li class="navelem"><a class="el" href="namespaceForSyDe_1_1SY.html">SY</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ForSyDe::SY Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for synchronous MoC.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1apply.html">apply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational adaptive process with one input and one output.  <a href="classForSyDe_1_1SY_1_1apply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1comb.html">comb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with one input and one output.  <a href="classForSyDe_1_1SY_1_1comb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1comb2.html">comb2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with two inputs and one output.  <a href="classForSyDe_1_1SY_1_1comb2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1comb3.html">comb3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with three inputs and one output.  <a href="classForSyDe_1_1SY_1_1comb3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1comb4.html">comb4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with four inputs and one output.  <a href="classForSyDe_1_1SY_1_1comb4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1combX.html">combX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a combinational process with an array of inputs and one output.  <a href="classForSyDe_1_1SY_1_1combX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1constant.html">constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a constant source process.  <a href="classForSyDe_1_1SY_1_1constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1delay.html">delay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a delay element.  <a href="classForSyDe_1_1SY_1_1delay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1delayn.html">delayn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a n-delay element.  <a href="classForSyDe_1_1SY_1_1delayn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1fanout.html">fanout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a fan-out process with one input and one output.  <a href="classForSyDe_1_1SY_1_1fanout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1file__sink.html">file_sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a <a class="el" href="classForSyDe_1_1SY_1_1file__sink.html" title="Process constructor for a file_sink process. ">file_sink</a> process.  <a href="classForSyDe_1_1SY_1_1file__sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1file__source.html">file_source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a <a class="el" href="classForSyDe_1_1SY_1_1file__source.html" title="Process constructor for a file_source process. ">file_source</a> process.  <a href="classForSyDe_1_1SY_1_1file__source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1fill.html">fill</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a fill process.  <a href="classForSyDe_1_1SY_1_1fill.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1gaussian.html">gaussian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a Gaussian randome wave generator.  <a href="classForSyDe_1_1SY_1_1gaussian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1gdbwrap.html">gdbwrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a GDB wrapper with one input and one output.  <a href="classForSyDe_1_1SY_1_1gdbwrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1group.html">group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The group process with one input and one absent-extended output.  <a href="classForSyDe_1_1SY_1_1group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1hold.html">hold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a hold process.  <a href="classForSyDe_1_1SY_1_1hold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a Mealy machine.  <a href="classForSyDe_1_1SY_1_1mealy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a Moore machine.  <a href="classForSyDe_1_1SY_1_1moore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1pipewrap.html">pipewrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a pipe wrapper with one input and one output.  <a href="classForSyDe_1_1SY_1_1pipewrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1pipewrap2.html">pipewrap2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a pipe wrapper with one input and one output.  <a href="classForSyDe_1_1SY_1_1pipewrap2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1receiver.html">receiver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a receiver process with one output.  <a href="classForSyDe_1_1SY_1_1receiver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1scomb.html">scomb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict combinational process with one input and one output.  <a href="classForSyDe_1_1SY_1_1scomb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1scomb2.html">scomb2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict combinational process with two inputs and one output.  <a href="classForSyDe_1_1SY_1_1scomb2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1scomb3.html">scomb3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict combinational process with three inputs and one output.  <a href="classForSyDe_1_1SY_1_1scomb3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1scomb4.html">scomb4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict combinational process with four inputs and one output.  <a href="classForSyDe_1_1SY_1_1scomb4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1scombX.html">scombX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict combinational process with an array of inputs and one output.  <a href="classForSyDe_1_1SY_1_1scombX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sconstant.html">sconstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict constant source process.  <a href="classForSyDe_1_1SY_1_1sconstant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sdelay.html">sdelay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict delay element.  <a href="classForSyDe_1_1SY_1_1sdelay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sdelayn.html">sdelayn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict n-delay element.  <a href="classForSyDe_1_1SY_1_1sdelayn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sdpmap.html">sdpmap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data-parallel process constructor for a strict combinational process with input and output array types.  <a href="classForSyDe_1_1SY_1_1sdpmap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sdpreduce.html">sdpreduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data-parallel process constructor for a strict reduce process with an array of inputs and one output.  <a href="classForSyDe_1_1SY_1_1sdpreduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sdpscan.html">sdpscan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A data-parallel process constructor for a strict scan process with input and output array types.  <a href="classForSyDe_1_1SY_1_1sdpscan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sender.html">sender</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a sender process with one input.  <a href="classForSyDe_1_1SY_1_1sender.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sgroup.html">sgroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strict group process with one input and one output.  <a href="classForSyDe_1_1SY_1_1sgroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sink.html">sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a sink process.  <a href="classForSyDe_1_1SY_1_1sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict Mealy machine.  <a href="classForSyDe_1_1SY_1_1smealy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict Moore machine.  <a href="classForSyDe_1_1SY_1_1smoore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1source.html">source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a source process.  <a href="classForSyDe_1_1SY_1_1source.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1ssink.html">ssink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict sink process.  <a href="classForSyDe_1_1SY_1_1ssink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1ssource.html">ssource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict source process.  <a href="classForSyDe_1_1SY_1_1ssource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sunzip.html">sunzip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strict unzip process with one input and two outputs.  <a href="classForSyDe_1_1SY_1_1sunzip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sunzipN.html">sunzipN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unzip process with one input and variable number of outputs.  <a href="classForSyDe_1_1SY_1_1sunzipN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1sunzipX.html">sunzipX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1SY_1_1sunzipX.html" title="The sunzipX process with one input and an array of outputs. ">sunzipX</a> process with one input and an array of outputs.  <a href="classForSyDe_1_1SY_1_1sunzipX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1svsource.html">svsource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a strict source process with vector input.  <a href="classForSyDe_1_1SY_1_1svsource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1SY2SY.html">SY2SY</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1SY_1_1SY2SY.html" title="The SY2SY signal used to inter-connect SY processes. ">SY2SY</a> signal used to inter-connect <a class="el" href="namespaceForSyDe_1_1SY.html" title="The namespace for synchronous MoC. ">SY</a> processes.  <a href="classForSyDe_1_1SY_1_1SY2SY.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1SY__in.html">SY_in</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1SY_1_1SY__in.html" title="The SY_in port is used for input ports of SY processes. ">SY_in</a> port is used for input ports of <a class="el" href="namespaceForSyDe_1_1SY.html" title="The namespace for synchronous MoC. ">SY</a> processes.  <a href="classForSyDe_1_1SY_1_1SY__in.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1SY__out.html">SY_out</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1SY_1_1SY__out.html" title="The SY_out port is used for output ports of SY processes. ">SY_out</a> port is used for output ports of <a class="el" href="namespaceForSyDe_1_1SY.html" title="The namespace for synchronous MoC. ">SY</a> processes.  <a href="classForSyDe_1_1SY_1_1SY__out.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1szip.html">szip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strict zip process with two inputs and one output.  <a href="classForSyDe_1_1SY_1_1szip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1szipN.html">szipN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strict zip process with variable number of inputs and one output.  <a href="classForSyDe_1_1SY_1_1szipN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1szipX.html">szipX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strict <a class="el" href="classForSyDe_1_1SY_1_1zipX.html" title="The zipX process with an array of inputs and one output. ">zipX</a> process with an array of inputs and one output.  <a href="classForSyDe_1_1SY_1_1szipX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1unzip.html">unzip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unzip process with one input and two outputs.  <a href="classForSyDe_1_1SY_1_1unzip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1unzipN.html">unzipN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unzip process with one input and variable number of outputs.  <a href="classForSyDe_1_1SY_1_1unzipN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1unzipX.html">unzipX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process with one input and an array of outputs.  <a href="classForSyDe_1_1SY_1_1unzipX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1vsource.html">vsource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constructor for a source process with vector input.  <a href="classForSyDe_1_1SY_1_1vsource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1zip.html">zip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The zip process with two inputs and one output.  <a href="classForSyDe_1_1SY_1_1zip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1zipN.html">zipN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The zip process with variable number of inputs and one output.  <a href="classForSyDe_1_1SY_1_1zipN.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classForSyDe_1_1SY_1_1zipX.html">zipX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classForSyDe_1_1SY_1_1zipX.html" title="The zipX process with an array of inputs and one output. ">zipX</a> process with an array of inputs and one output.  <a href="classForSyDe_1_1SY_1_1zipX.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a26ee0cf275cec7837c493a1499bd46d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a26ee0cf275cec7837c493a1499bd46d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26ee0cf275cec7837c493a1499bd46d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a26ee0cf275cec7837c493a1499bd46d9">signal</a> = <a class="el" href="classForSyDe_1_1SY_1_1SY2SY.html">SY2SY</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a26ee0cf275cec7837c493a1499bd46d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceForSyDe_1_1SY.html#a26ee0cf275cec7837c493a1499bd46d9" title="The SY::signal is an alias for SY::SY2SY. ">SY::signal</a> is an alias for <a class="el" href="classForSyDe_1_1SY_1_1SY2SY.html" title="The SY2SY signal used to inter-connect SY processes. ">SY::SY2SY</a>. <br /></td></tr>
<tr class="separator:a26ee0cf275cec7837c493a1499bd46d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9283667cc5362fa40e3ba32da410d6c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9283667cc5362fa40e3ba32da410d6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9283667cc5362fa40e3ba32da410d6c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aa9283667cc5362fa40e3ba32da410d6c">in_port</a> = <a class="el" href="classForSyDe_1_1SY_1_1SY__in.html">SY_in</a>&lt; T &gt;</td></tr>
<tr class="memdesc:aa9283667cc5362fa40e3ba32da410d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceForSyDe_1_1SY.html#aa9283667cc5362fa40e3ba32da410d6c" title="The SY::in_port is an alias for SY::SY_in. ">SY::in_port</a> is an alias for <a class="el" href="classForSyDe_1_1SY_1_1SY__in.html" title="The SY_in port is used for input ports of SY processes. ">SY::SY_in</a>. <br /></td></tr>
<tr class="separator:aa9283667cc5362fa40e3ba32da410d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4321233d5934e007d383b40e8ce065"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca4321233d5934e007d383b40e8ce065"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca4321233d5934e007d383b40e8ce065"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aca4321233d5934e007d383b40e8ce065">out_port</a> = <a class="el" href="classForSyDe_1_1SY_1_1SY__out.html">SY_out</a>&lt; T &gt;</td></tr>
<tr class="memdesc:aca4321233d5934e007d383b40e8ce065"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceForSyDe_1_1SY.html#aca4321233d5934e007d383b40e8ce065" title="The SY::out_port is an alias for SY::SY_out. ">SY::out_port</a> is an alias for <a class="el" href="classForSyDe_1_1SY_1_1SY__out.html" title="The SY_out port is used for output ports of SY processes. ">SY::SY_out</a>. <br /></td></tr>
<tr class="separator:aca4321233d5934e007d383b40e8ce065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa953b487c613b669ee697046cadfb77d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa953b487c613b669ee697046cadfb77d"></a>
typedef <a class="el" href="classForSyDe_1_1process.html">ForSyDe::process</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aa953b487c613b669ee697046cadfb77d">sy_process</a></td></tr>
<tr class="memdesc:aa953b487c613b669ee697046cadfb77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract semantics of a process in the <a class="el" href="namespaceForSyDe_1_1SY.html" title="The namespace for synchronous MoC. ">SY</a> MoC. <br /></td></tr>
<tr class="separator:aa953b487c613b669ee697046cadfb77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb63d4692c64b3f67c21bc08a7a013b7"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, template&lt; class &gt; class FIf&gt; </td></tr>
<tr class="memitem:afb63d4692c64b3f67c21bc08a7a013b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1apply.html">apply</a>&lt; T0, T1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#afb63d4692c64b3f67c21bc08a7a013b7">make_apply</a> (const std::string &amp;pName, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, FIf&lt; typename <a class="el" href="classForSyDe_1_1SY_1_1apply.html">apply</a>&lt; T0, T1 &gt;::functype &gt; &amp;fS)</td></tr>
<tr class="memdesc:afb63d4692c64b3f67c21bc08a7a013b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a comb process.  <a href="#afb63d4692c64b3f67c21bc08a7a013b7">More...</a><br /></td></tr>
<tr class="separator:afb63d4692c64b3f67c21bc08a7a013b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a310646284bf8f390ed5f04e317001"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class I0If&gt; </td></tr>
<tr class="memitem:ae5a310646284bf8f390ed5f04e317001"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sender.html">sender</a>&lt; T0 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ae5a310646284bf8f390ed5f04e317001">make_sender</a> (const std::string &amp;pName, int destination, int tag, I0If&lt; T0 &gt; &amp;inp1S)</td></tr>
<tr class="memdesc:ae5a310646284bf8f390ed5f04e317001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sender process.  <a href="#ae5a310646284bf8f390ed5f04e317001">More...</a><br /></td></tr>
<tr class="separator:ae5a310646284bf8f390ed5f04e317001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbf212ac85c54c4ddb5e89b8889e65b"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:addbf212ac85c54c4ddb5e89b8889e65b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1receiver.html">receiver</a>&lt; T0 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#addbf212ac85c54c4ddb5e89b8889e65b">make_receiver</a> (const std::string &amp;pName, int <a class="el" href="classForSyDe_1_1SY_1_1source.html">source</a>, int tag, OIf&lt; T0 &gt; &amp;outS)</td></tr>
<tr class="memdesc:addbf212ac85c54c4ddb5e89b8889e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sender process.  <a href="#addbf212ac85c54c4ddb5e89b8889e65b">More...</a><br /></td></tr>
<tr class="separator:addbf212ac85c54c4ddb5e89b8889e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d770d2ccab943683243a0de966f89c"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </td></tr>
<tr class="memitem:a87d770d2ccab943683243a0de966f89c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1comb.html">comb</a>&lt; T0, T1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a87d770d2ccab943683243a0de966f89c">make_comb</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1comb.html">comb</a>&lt; T0, T1 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S)</td></tr>
<tr class="memdesc:a87d770d2ccab943683243a0de966f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a comb process.  <a href="#a87d770d2ccab943683243a0de966f89c">More...</a><br /></td></tr>
<tr class="separator:a87d770d2ccab943683243a0de966f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61b15d0c27d677b99ad63f05373be50"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If&gt; </td></tr>
<tr class="memitem:aa61b15d0c27d677b99ad63f05373be50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1comb2.html">comb2</a>&lt; T0, T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aa61b15d0c27d677b99ad63f05373be50">make_comb2</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1comb2.html">comb2</a>&lt; T0, T1, T2 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S)</td></tr>
<tr class="memdesc:aa61b15d0c27d677b99ad63f05373be50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1comb2.html" title="Process constructor for a combinational process with two inputs and one output. ">comb2</a> process.  <a href="#aa61b15d0c27d677b99ad63f05373be50">More...</a><br /></td></tr>
<tr class="separator:aa61b15d0c27d677b99ad63f05373be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46975052ec2025ddf543b98ce7d664a2"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If&gt; </td></tr>
<tr class="memitem:a46975052ec2025ddf543b98ce7d664a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1comb3.html">comb3</a>&lt; T0, T1, T2, T3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a46975052ec2025ddf543b98ce7d664a2">make_comb3</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1comb3.html">comb3</a>&lt; T0, T1, T2, T3 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S, I3If&lt; T3 &gt; &amp;inp3S)</td></tr>
<tr class="memdesc:a46975052ec2025ddf543b98ce7d664a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1comb3.html" title="Process constructor for a combinational process with three inputs and one output. ...">comb3</a> process.  <a href="#a46975052ec2025ddf543b98ce7d664a2">More...</a><br /></td></tr>
<tr class="separator:a46975052ec2025ddf543b98ce7d664a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daf479d32ff8fd32adf05eb72d00389"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If, class T4 , template&lt; class &gt; class I4If&gt; </td></tr>
<tr class="memitem:a1daf479d32ff8fd32adf05eb72d00389"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1comb4.html">comb4</a>&lt; T0, T1, T2, T3, T4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a1daf479d32ff8fd32adf05eb72d00389">make_comb4</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1comb4.html">comb4</a>&lt; T0, T1, T2, T3, T4 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S, I3If&lt; T3 &gt; &amp;inp3S, I4If&lt; T4 &gt; &amp;inp4S)</td></tr>
<tr class="memdesc:a1daf479d32ff8fd32adf05eb72d00389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1comb4.html" title="Process constructor for a combinational process with four inputs and one output. ">comb4</a> process.  <a href="#a1daf479d32ff8fd32adf05eb72d00389">More...</a><br /></td></tr>
<tr class="separator:a1daf479d32ff8fd32adf05eb72d00389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9f288c9dce4acfba5a4a112059c99a"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </td></tr>
<tr class="memitem:a6c9f288c9dce4acfba5a4a112059c99a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1combX.html">combX</a>&lt; T0, T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a6c9f288c9dce4acfba5a4a112059c99a">make_combX</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1combX.html">combX</a>&lt; T0, T1, N &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, std::array&lt; IIf&lt; T1 &gt;, N &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a6c9f288c9dce4acfba5a4a112059c99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1combX.html" title="Process constructor for a combinational process with an array of inputs and one output. ">combX</a> process.  <a href="#a6c9f288c9dce4acfba5a4a112059c99a">More...</a><br /></td></tr>
<tr class="separator:a6c9f288c9dce4acfba5a4a112059c99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e824696a2205f8391f4b6cf01111e4"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a54e824696a2205f8391f4b6cf01111e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1delay.html">delay</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a54e824696a2205f8391f4b6cf01111e4">make_delay</a> (const std::string &amp;pName, const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;initval, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a54e824696a2205f8391f4b6cf01111e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a delay process.  <a href="#a54e824696a2205f8391f4b6cf01111e4">More...</a><br /></td></tr>
<tr class="separator:a54e824696a2205f8391f4b6cf01111e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade590b304bcdded02c2ebdab9e3ac32b"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:ade590b304bcdded02c2ebdab9e3ac32b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1delayn.html">delayn</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ade590b304bcdded02c2ebdab9e3ac32b">make_delayn</a> (const std::string &amp;pName, const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;initval, const unsigned int &amp;n, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:ade590b304bcdded02c2ebdab9e3ac32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a delayn process.  <a href="#ade590b304bcdded02c2ebdab9e3ac32b">More...</a><br /></td></tr>
<tr class="separator:ade590b304bcdded02c2ebdab9e3ac32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e583babb654a0c8239aee156f55c48f"><td class="memTemplParams" colspan="2">template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a7e583babb654a0c8239aee156f55c48f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a>&lt; IT, ST, OT &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a7e583babb654a0c8239aee156f55c48f">make_moore</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a>&lt; IT, ST, OT &gt;::ns_functype &amp;_ns_func, const typename <a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a>&lt; IT, ST, OT &gt;::od_functype &amp;_od_func, const ST &amp;init_st, OIf&lt; OT &gt; &amp;outS, IIf&lt; IT &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a7e583babb654a0c8239aee156f55c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a moore process.  <a href="#a7e583babb654a0c8239aee156f55c48f">More...</a><br /></td></tr>
<tr class="separator:a7e583babb654a0c8239aee156f55c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf66281dab2362f99fee2bfac9e6a986"><td class="memTemplParams" colspan="2">template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:abf66281dab2362f99fee2bfac9e6a986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a>&lt; IT, ST, OT &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#abf66281dab2362f99fee2bfac9e6a986">make_mealy</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a>&lt; IT, ST, OT &gt;::ns_functype &amp;_ns_func, const typename <a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a>&lt; IT, ST, OT &gt;::od_functype &amp;_od_func, const ST &amp;init_st, OIf&lt; OT &gt; &amp;outS, IIf&lt; IT &gt; &amp;inpS)</td></tr>
<tr class="memdesc:abf66281dab2362f99fee2bfac9e6a986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a mealy process.  <a href="#abf66281dab2362f99fee2bfac9e6a986">More...</a><br /></td></tr>
<tr class="separator:abf66281dab2362f99fee2bfac9e6a986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab69eb1bb9e05accb50680f02b74618"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a8ab69eb1bb9e05accb50680f02b74618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1fill.html">fill</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a8ab69eb1bb9e05accb50680f02b74618">make_fill</a> (const std::string &amp;pName, const T &amp;def_val, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a8ab69eb1bb9e05accb50680f02b74618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a fill process.  <a href="#a8ab69eb1bb9e05accb50680f02b74618">More...</a><br /></td></tr>
<tr class="separator:a8ab69eb1bb9e05accb50680f02b74618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eec84602a91ad67b2116a7c3bfd7afb"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a0eec84602a91ad67b2116a7c3bfd7afb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1hold.html">hold</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a0eec84602a91ad67b2116a7c3bfd7afb">make_hold</a> (const std::string &amp;pName, const T &amp;def_val, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a0eec84602a91ad67b2116a7c3bfd7afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a hold process.  <a href="#a0eec84602a91ad67b2116a7c3bfd7afb">More...</a><br /></td></tr>
<tr class="separator:a0eec84602a91ad67b2116a7c3bfd7afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7fca57669172abf2a71ace5b22d2dd"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a3b7fca57669172abf2a71ace5b22d2dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1group.html">group</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a3b7fca57669172abf2a71ace5b22d2dd">make_group</a> (const std::string &amp;pName, const unsigned long &amp;samples, OIf&lt; std::vector&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt;&gt;&gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a3b7fca57669172abf2a71ace5b22d2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a group process.  <a href="#a3b7fca57669172abf2a71ace5b22d2dd">More...</a><br /></td></tr>
<tr class="separator:a3b7fca57669172abf2a71ace5b22d2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab639431eaf8ef9f08a5fb8c168b62e49"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:ab639431eaf8ef9f08a5fb8c168b62e49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1constant.html">constant</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ab639431eaf8ef9f08a5fb8c168b62e49">make_constant</a> (const std::string &amp;pName, const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;initval, const unsigned long long &amp;take, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:ab639431eaf8ef9f08a5fb8c168b62e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a constant source process.  <a href="#ab639431eaf8ef9f08a5fb8c168b62e49">More...</a><br /></td></tr>
<tr class="separator:ab639431eaf8ef9f08a5fb8c168b62e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe96091c397991785ff3d4db4d10595"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a7fe96091c397991785ff3d4db4d10595"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1source.html">source</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a7fe96091c397991785ff3d4db4d10595">make_source</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1source.html">source</a>&lt; T &gt;::functype &amp;_func, const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;initval, const unsigned long long &amp;take, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:a7fe96091c397991785ff3d4db4d10595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a source process.  <a href="#a7fe96091c397991785ff3d4db4d10595">More...</a><br /></td></tr>
<tr class="separator:a7fe96091c397991785ff3d4db4d10595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0339bebf674166d86b372308ab009f5"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:ae0339bebf674166d86b372308ab009f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1file__source.html">file_source</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ae0339bebf674166d86b372308ab009f5">make_file_source</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1SY_1_1file__source.html">file_source</a>&lt; T &gt;::functype _func, std::string file_name, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:ae0339bebf674166d86b372308ab009f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1file__source.html" title="Process constructor for a file_source process. ">file_source</a> process.  <a href="#ae0339bebf674166d86b372308ab009f5">More...</a><br /></td></tr>
<tr class="separator:ae0339bebf674166d86b372308ab009f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040747a75c27e56d6816377a2e817b44"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a040747a75c27e56d6816377a2e817b44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1vsource.html">vsource</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a040747a75c27e56d6816377a2e817b44">make_vsource</a> (const std::string &amp;pName, const std::vector&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt;&gt; &amp;in_vec, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:a040747a75c27e56d6816377a2e817b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a vector source process.  <a href="#a040747a75c27e56d6816377a2e817b44">More...</a><br /></td></tr>
<tr class="separator:a040747a75c27e56d6816377a2e817b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd3ed84f9a1020af6d317efbc42e366"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class IIf&gt; </td></tr>
<tr class="memitem:a3cd3ed84f9a1020af6d317efbc42e366"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sink.html">sink</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a3cd3ed84f9a1020af6d317efbc42e366">make_sink</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1sink.html">sink</a>&lt; T &gt;::functype &amp;_func, IIf&lt; T &gt; &amp;inS)</td></tr>
<tr class="memdesc:a3cd3ed84f9a1020af6d317efbc42e366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sink process.  <a href="#a3cd3ed84f9a1020af6d317efbc42e366">More...</a><br /></td></tr>
<tr class="separator:a3cd3ed84f9a1020af6d317efbc42e366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5edc3da212b9904eec309e5fed1d99"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class IIf&gt; </td></tr>
<tr class="memitem:a2b5edc3da212b9904eec309e5fed1d99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1file__sink.html">file_sink</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a2b5edc3da212b9904eec309e5fed1d99">make_file_sink</a> (std::string pName, typename <a class="el" href="classForSyDe_1_1SY_1_1file__sink.html">file_sink</a>&lt; T &gt;::functype _func, std::string file_name, IIf&lt; T &gt; &amp;inS)</td></tr>
<tr class="memdesc:a2b5edc3da212b9904eec309e5fed1d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1file__sink.html" title="Process constructor for a file_sink process. ">file_sink</a> process.  <a href="#a2b5edc3da212b9904eec309e5fed1d99">More...</a><br /></td></tr>
<tr class="separator:a2b5edc3da212b9904eec309e5fed1d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f502bb45bc4e38fda5f5cff37a26d3e"><td class="memTemplParams" colspan="2">template&lt;class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a9f502bb45bc4e38fda5f5cff37a26d3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1zip.html">zip</a>&lt; T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a9f502bb45bc4e38fda5f5cff37a26d3e">make_zip</a> (const std::string &amp;pName, OIf&lt; std::tuple&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T2 &gt;&gt;&gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S)</td></tr>
<tr class="memdesc:a9f502bb45bc4e38fda5f5cff37a26d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a zip process.  <a href="#a9f502bb45bc4e38fda5f5cff37a26d3e">More...</a><br /></td></tr>
<tr class="separator:a9f502bb45bc4e38fda5f5cff37a26d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9bf797bccc439af4fa252ffd7563bb"><td class="memTemplParams" colspan="2">template&lt;class T1 , std::size_t N, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a1a9bf797bccc439af4fa252ffd7563bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1zipX.html">zipX</a>&lt; T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a1a9bf797bccc439af4fa252ffd7563bb">make_zipX</a> (const std::string &amp;pName, OIf&lt; std::array&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, N &gt;&gt; &amp;outS)</td></tr>
<tr class="memdesc:a1a9bf797bccc439af4fa252ffd7563bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1zipX.html" title="The zipX process with an array of inputs and one output. ">zipX</a> process.  <a href="#a1a9bf797bccc439af4fa252ffd7563bb">More...</a><br /></td></tr>
<tr class="separator:a1a9bf797bccc439af4fa252ffd7563bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb297a58cbb9fb20dc48337bc82af29"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class IIf, class T1 , template&lt; class &gt; class O1If, class T2 , template&lt; class &gt; class O2If&gt; </td></tr>
<tr class="memitem:a4fb297a58cbb9fb20dc48337bc82af29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1unzip.html">unzip</a>&lt; T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a4fb297a58cbb9fb20dc48337bc82af29">make_unzip</a> (const std::string &amp;pName, IIf&lt; std::tuple&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T2 &gt;&gt;&gt; &amp;inpS, O1If&lt; T1 &gt; &amp;out1S, O2If&lt; T2 &gt; &amp;out2S)</td></tr>
<tr class="memdesc:a4fb297a58cbb9fb20dc48337bc82af29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct an unzip process.  <a href="#a4fb297a58cbb9fb20dc48337bc82af29">More...</a><br /></td></tr>
<tr class="separator:a4fb297a58cbb9fb20dc48337bc82af29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231edbef798b2e0d6aa1b722e716fd7a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class IIf, class T1 , std::size_t N&gt; </td></tr>
<tr class="memitem:a231edbef798b2e0d6aa1b722e716fd7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1unzipX.html">unzipX</a>&lt; T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a231edbef798b2e0d6aa1b722e716fd7a">make_unzipX</a> (const std::string &amp;pName, IIf&lt; std::array&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, N &gt;&gt; &amp;inpS)</td></tr>
<tr class="memdesc:a231edbef798b2e0d6aa1b722e716fd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct an <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process.  <a href="#a231edbef798b2e0d6aa1b722e716fd7a">More...</a><br /></td></tr>
<tr class="separator:a231edbef798b2e0d6aa1b722e716fd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87376d15c9eb8416a17eb227529f0fc"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:aa87376d15c9eb8416a17eb227529f0fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1fanout.html">fanout</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aa87376d15c9eb8416a17eb227529f0fc">make_fanout</a> (const std::string &amp;pName, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:aa87376d15c9eb8416a17eb227529f0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a fanout process.  <a href="#aa87376d15c9eb8416a17eb227529f0fc">More...</a><br /></td></tr>
<tr class="separator:aa87376d15c9eb8416a17eb227529f0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4aea80c3de01819bcf03cf42cce669"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </td></tr>
<tr class="memitem:a1a4aea80c3de01819bcf03cf42cce669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1scomb.html">scomb</a>&lt; T0, T1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a1a4aea80c3de01819bcf03cf42cce669">make_scomb</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb.html">scomb</a>&lt; T0, T1 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S)</td></tr>
<tr class="memdesc:a1a4aea80c3de01819bcf03cf42cce669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict comb process.  <a href="#a1a4aea80c3de01819bcf03cf42cce669">More...</a><br /></td></tr>
<tr class="separator:a1a4aea80c3de01819bcf03cf42cce669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a94af6584aabda25ff033f6c707c70"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If&gt; </td></tr>
<tr class="memitem:a59a94af6584aabda25ff033f6c707c70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1scomb2.html">scomb2</a>&lt; T0, T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a59a94af6584aabda25ff033f6c707c70">make_scomb2</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb2.html">scomb2</a>&lt; T0, T1, T2 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S)</td></tr>
<tr class="memdesc:a59a94af6584aabda25ff033f6c707c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1comb2.html" title="Process constructor for a combinational process with two inputs and one output. ">comb2</a> process.  <a href="#a59a94af6584aabda25ff033f6c707c70">More...</a><br /></td></tr>
<tr class="separator:a59a94af6584aabda25ff033f6c707c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d7f3aab5a03a118df8df3bc7bed19e"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If&gt; </td></tr>
<tr class="memitem:a85d7f3aab5a03a118df8df3bc7bed19e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1scomb3.html">scomb3</a>&lt; T0, T1, T2, T3 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a85d7f3aab5a03a118df8df3bc7bed19e">make_scomb3</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb3.html">scomb3</a>&lt; T0, T1, T2, T3 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S, I3If&lt; T3 &gt; &amp;inp3S)</td></tr>
<tr class="memdesc:a85d7f3aab5a03a118df8df3bc7bed19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1comb3.html" title="Process constructor for a combinational process with three inputs and one output. ...">comb3</a> process.  <a href="#a85d7f3aab5a03a118df8df3bc7bed19e">More...</a><br /></td></tr>
<tr class="separator:a85d7f3aab5a03a118df8df3bc7bed19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea403a33546132f38f3b1456d82964c2"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If, class T4 , template&lt; class &gt; class I4If&gt; </td></tr>
<tr class="memitem:aea403a33546132f38f3b1456d82964c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1scomb4.html">scomb4</a>&lt; T0, T1, T2, T3, T4 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aea403a33546132f38f3b1456d82964c2">make_scomb4</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb4.html">scomb4</a>&lt; T0, T1, T2, T3, T4 &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S, I3If&lt; T3 &gt; &amp;inp3S, I4If&lt; T4 &gt; &amp;inp4S)</td></tr>
<tr class="memdesc:aea403a33546132f38f3b1456d82964c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1comb4.html" title="Process constructor for a combinational process with four inputs and one output. ">comb4</a> process.  <a href="#aea403a33546132f38f3b1456d82964c2">More...</a><br /></td></tr>
<tr class="separator:aea403a33546132f38f3b1456d82964c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a494588228c52f760a86f645e44e77"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </td></tr>
<tr class="memitem:ae5a494588228c52f760a86f645e44e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1scombX.html">scombX</a>&lt; T0, T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ae5a494588228c52f760a86f645e44e77">make_scombX</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1scombX.html">scombX</a>&lt; T0, T1, N &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, std::array&lt; IIf&lt; T1 &gt;, N &gt; &amp;inpS)</td></tr>
<tr class="memdesc:ae5a494588228c52f760a86f645e44e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1combX.html" title="Process constructor for a combinational process with an array of inputs and one output. ">combX</a> process.  <a href="#ae5a494588228c52f760a86f645e44e77">More...</a><br /></td></tr>
<tr class="separator:ae5a494588228c52f760a86f645e44e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b9bc0bf4ec7050c53ca1fec0776abf"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </td></tr>
<tr class="memitem:a40b9bc0bf4ec7050c53ca1fec0776abf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sdpmap.html">sdpmap</a>&lt; T0, T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a40b9bc0bf4ec7050c53ca1fec0776abf">make_sdpmap</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1sdpmap.html">sdpmap</a>&lt; T0, T1, N &gt;::functype &amp;_func, OIf&lt; std::array&lt; T0, N &gt;&gt; &amp;outS, IIf&lt; std::array&lt; T1, N &gt;&gt; &amp;inpS)</td></tr>
<tr class="memdesc:a40b9bc0bf4ec7050c53ca1fec0776abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict data parallel comb process.  <a href="#a40b9bc0bf4ec7050c53ca1fec0776abf">More...</a><br /></td></tr>
<tr class="separator:a40b9bc0bf4ec7050c53ca1fec0776abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a86f91a11fc08f9c65db17b34b7203"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, template&lt; class &gt; class IIf, std::size_t N&gt; </td></tr>
<tr class="memitem:ad8a86f91a11fc08f9c65db17b34b7203"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sdpreduce.html">sdpreduce</a>&lt; T0, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ad8a86f91a11fc08f9c65db17b34b7203">make_sdpreduce</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1sdpreduce.html">sdpreduce</a>&lt; T0, N &gt;::functype &amp;_func, OIf&lt; T0 &gt; &amp;outS, IIf&lt; std::array&lt; T0, N &gt;&gt; &amp;inpS)</td></tr>
<tr class="memdesc:ad8a86f91a11fc08f9c65db17b34b7203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict reduce process.  <a href="#ad8a86f91a11fc08f9c65db17b34b7203">More...</a><br /></td></tr>
<tr class="separator:ad8a86f91a11fc08f9c65db17b34b7203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608f1c2f13be19bdbdb0a6523543735d"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </td></tr>
<tr class="memitem:a608f1c2f13be19bdbdb0a6523543735d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sdpscan.html">sdpscan</a>&lt; T0, T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a608f1c2f13be19bdbdb0a6523543735d">make_sdpscan</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1sdpscan.html">sdpscan</a>&lt; T0, T1, N &gt;::functype &amp;_func, const T0 &amp;init_res, OIf&lt; std::array&lt; T0, N &gt;&gt; &amp;outS, IIf&lt; std::array&lt; T1, N &gt;&gt; &amp;inpS)</td></tr>
<tr class="memdesc:a608f1c2f13be19bdbdb0a6523543735d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict data parallel scan process.  <a href="#a608f1c2f13be19bdbdb0a6523543735d">More...</a><br /></td></tr>
<tr class="separator:a608f1c2f13be19bdbdb0a6523543735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4790f7fa7967c91d3c7739bc09ee3739"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a4790f7fa7967c91d3c7739bc09ee3739"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sdelay.html">sdelay</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a4790f7fa7967c91d3c7739bc09ee3739">make_sdelay</a> (const std::string &amp;pName, const T &amp;initval, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a4790f7fa7967c91d3c7739bc09ee3739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict delay process.  <a href="#a4790f7fa7967c91d3c7739bc09ee3739">More...</a><br /></td></tr>
<tr class="separator:a4790f7fa7967c91d3c7739bc09ee3739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7792c329909728bede11cb8333f9ca9e"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a7792c329909728bede11cb8333f9ca9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sdelayn.html">sdelayn</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a7792c329909728bede11cb8333f9ca9e">make_sdelayn</a> (const std::string &amp;pName, const T &amp;initval, const unsigned int &amp;n, OIf&lt; T &gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a7792c329909728bede11cb8333f9ca9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict delayn process.  <a href="#a7792c329909728bede11cb8333f9ca9e">More...</a><br /></td></tr>
<tr class="separator:a7792c329909728bede11cb8333f9ca9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0183e954d89a20dc36c9f5ceb16581d"><td class="memTemplParams" colspan="2">template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:ab0183e954d89a20dc36c9f5ceb16581d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a>&lt; IT, ST, OT &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ab0183e954d89a20dc36c9f5ceb16581d">make_smoore</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a>&lt; IT, ST, OT &gt;::ns_functype &amp;_ns_func, const typename <a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a>&lt; IT, ST, OT &gt;::od_functype &amp;_od_func, const ST &amp;init_st, OIf&lt; OT &gt; &amp;outS, IIf&lt; IT &gt; &amp;inpS)</td></tr>
<tr class="memdesc:ab0183e954d89a20dc36c9f5ceb16581d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a moore process.  <a href="#ab0183e954d89a20dc36c9f5ceb16581d">More...</a><br /></td></tr>
<tr class="separator:ab0183e954d89a20dc36c9f5ceb16581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c7f3c4dddee63bf8e9b0dbd0e5a3d3"><td class="memTemplParams" colspan="2">template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a37c7f3c4dddee63bf8e9b0dbd0e5a3d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a>&lt; IT, ST, OT &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a37c7f3c4dddee63bf8e9b0dbd0e5a3d3">make_smealy</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a>&lt; IT, ST, OT &gt;::ns_functype &amp;_ns_func, const typename <a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a>&lt; IT, ST, OT &gt;::od_functype &amp;_od_func, const ST &amp;init_st, OIf&lt; OT &gt; &amp;outS, IIf&lt; IT &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a37c7f3c4dddee63bf8e9b0dbd0e5a3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict mealy process.  <a href="#a37c7f3c4dddee63bf8e9b0dbd0e5a3d3">More...</a><br /></td></tr>
<tr class="separator:a37c7f3c4dddee63bf8e9b0dbd0e5a3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c759e4614db2279402d6d8cb372caa0"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a1c759e4614db2279402d6d8cb372caa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sgroup.html">sgroup</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a1c759e4614db2279402d6d8cb372caa0">make_sgroup</a> (const std::string &amp;pName, const unsigned long &amp;samples, OIf&lt; std::vector&lt; T &gt;&gt; &amp;outS, IIf&lt; T &gt; &amp;inpS)</td></tr>
<tr class="memdesc:a1c759e4614db2279402d6d8cb372caa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict group process.  <a href="#a1c759e4614db2279402d6d8cb372caa0">More...</a><br /></td></tr>
<tr class="separator:a1c759e4614db2279402d6d8cb372caa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1fe7a287569dd72f7bcb8d1d6353fc"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:ada1fe7a287569dd72f7bcb8d1d6353fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sconstant.html">sconstant</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ada1fe7a287569dd72f7bcb8d1d6353fc">make_sconstant</a> (const std::string &amp;pName, const T &amp;initval, const unsigned long long &amp;take, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:ada1fe7a287569dd72f7bcb8d1d6353fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict constant source process.  <a href="#ada1fe7a287569dd72f7bcb8d1d6353fc">More...</a><br /></td></tr>
<tr class="separator:ada1fe7a287569dd72f7bcb8d1d6353fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4615aef7b6f79ee081fc853c1da53f43"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a4615aef7b6f79ee081fc853c1da53f43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1ssource.html">ssource</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a4615aef7b6f79ee081fc853c1da53f43">make_ssource</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1ssource.html">ssource</a>&lt; T &gt;::functype &amp;_func, const T &amp;initval, const unsigned long long &amp;take, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:a4615aef7b6f79ee081fc853c1da53f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict source process.  <a href="#a4615aef7b6f79ee081fc853c1da53f43">More...</a><br /></td></tr>
<tr class="separator:a4615aef7b6f79ee081fc853c1da53f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e86cf0df2275d2c805c16dba6cda19f"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a7e86cf0df2275d2c805c16dba6cda19f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1svsource.html">svsource</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a7e86cf0df2275d2c805c16dba6cda19f">make_svsource</a> (const std::string &amp;pName, const std::vector&lt; T &gt; &amp;in_vec, OIf&lt; T &gt; &amp;outS)</td></tr>
<tr class="memdesc:a7e86cf0df2275d2c805c16dba6cda19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict vector source process.  <a href="#a7e86cf0df2275d2c805c16dba6cda19f">More...</a><br /></td></tr>
<tr class="separator:a7e86cf0df2275d2c805c16dba6cda19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64ca16ee881123f9453e7f57ad55f2d"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class IIf&gt; </td></tr>
<tr class="memitem:ab64ca16ee881123f9453e7f57ad55f2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1ssink.html">ssink</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#ab64ca16ee881123f9453e7f57ad55f2d">make_ssink</a> (const std::string &amp;pName, const typename <a class="el" href="classForSyDe_1_1SY_1_1ssink.html">ssink</a>&lt; T &gt;::functype &amp;_func, IIf&lt; T &gt; &amp;inS)</td></tr>
<tr class="memdesc:ab64ca16ee881123f9453e7f57ad55f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict sink process.  <a href="#ab64ca16ee881123f9453e7f57ad55f2d">More...</a><br /></td></tr>
<tr class="separator:ab64ca16ee881123f9453e7f57ad55f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aebb572d0be25950ae16730c9111da"><td class="memTemplParams" colspan="2">template&lt;class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a42aebb572d0be25950ae16730c9111da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1szip.html">szip</a>&lt; T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a42aebb572d0be25950ae16730c9111da">make_szip</a> (const std::string &amp;pName, OIf&lt; std::tuple&lt; T1, T2 &gt;&gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S)</td></tr>
<tr class="memdesc:a42aebb572d0be25950ae16730c9111da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a szip process.  <a href="#a42aebb572d0be25950ae16730c9111da">More...</a><br /></td></tr>
<tr class="separator:a42aebb572d0be25950ae16730c9111da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5553e0a09825433d644b15b351a37d"><td class="memTemplParams" colspan="2">template&lt;class T1 , std::size_t N, template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a9d5553e0a09825433d644b15b351a37d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1szipX.html">szipX</a>&lt; T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a9d5553e0a09825433d644b15b351a37d">make_szipX</a> (const std::string &amp;pName, OIf&lt; std::array&lt; T1, N &gt;&gt; &amp;outS)</td></tr>
<tr class="memdesc:a9d5553e0a09825433d644b15b351a37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1szipX.html" title="The strict zipX process with an array of inputs and one output. ">szipX</a> process.  <a href="#a9d5553e0a09825433d644b15b351a37d">More...</a><br /></td></tr>
<tr class="separator:a9d5553e0a09825433d644b15b351a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb225ef58122f33eb0559524ab6da2d5"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class IIf, class T1 , template&lt; class &gt; class O1If, class T2 , template&lt; class &gt; class O2If&gt; </td></tr>
<tr class="memitem:afb225ef58122f33eb0559524ab6da2d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1sunzip.html">sunzip</a>&lt; T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#afb225ef58122f33eb0559524ab6da2d5">make_sunzip</a> (const std::string &amp;pName, IIf&lt; std::tuple&lt; T1, T2 &gt;&gt; &amp;inpS, O1If&lt; T1 &gt; &amp;out1S, O2If&lt; T2 &gt; &amp;out2S)</td></tr>
<tr class="memdesc:afb225ef58122f33eb0559524ab6da2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a sunzip process.  <a href="#afb225ef58122f33eb0559524ab6da2d5">More...</a><br /></td></tr>
<tr class="separator:afb225ef58122f33eb0559524ab6da2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b046ecbb1e601af916ab688243950fa"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class IIf, class T1 , std::size_t N&gt; </td></tr>
<tr class="memitem:a7b046ecbb1e601af916ab688243950fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1unzipX.html">unzipX</a>&lt; T1, N &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a7b046ecbb1e601af916ab688243950fa">make_unzipX</a> (const std::string &amp;pName, IIf&lt; std::array&lt; T1, N &gt;&gt; &amp;inpS)</td></tr>
<tr class="memdesc:a7b046ecbb1e601af916ab688243950fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process.  <a href="#a7b046ecbb1e601af916ab688243950fa">More...</a><br /></td></tr>
<tr class="separator:a7b046ecbb1e601af916ab688243950fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7329f62457a853719bface871f35b736"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class OIf&gt; </td></tr>
<tr class="memitem:a7329f62457a853719bface871f35b736"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1gaussian.html">gaussian</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a7329f62457a853719bface871f35b736">make_gaussian</a> (const std::string &amp;pName, const double &amp;gaussVar, const double &amp;gaussMean, OIf&lt; double &gt; &amp;outS)</td></tr>
<tr class="memdesc:a7329f62457a853719bface871f35b736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a Gaussian randome wave generator.  <a href="#a7329f62457a853719bface871f35b736">More...</a><br /></td></tr>
<tr class="separator:a7329f62457a853719bface871f35b736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3801c2e6def022c4bce6d83279b831"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </td></tr>
<tr class="memitem:aaa3801c2e6def022c4bce6d83279b831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1gdbwrap.html">gdbwrap</a>&lt; T0, T1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aaa3801c2e6def022c4bce6d83279b831">make_gdbwrap</a> (const std::string &amp;pName, const std::string &amp;exec_name, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S)</td></tr>
<tr class="memdesc:aaa3801c2e6def022c4bce6d83279b831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a gdbwrap process.  <a href="#aaa3801c2e6def022c4bce6d83279b831">More...</a><br /></td></tr>
<tr class="separator:aaa3801c2e6def022c4bce6d83279b831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c12c637c011a35f3a14b2d80daaa61"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </td></tr>
<tr class="memitem:aa1c12c637c011a35f3a14b2d80daaa61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1pipewrap.html">pipewrap</a>&lt; T0, T1 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#aa1c12c637c011a35f3a14b2d80daaa61">make_pipewrap</a> (const std::string &amp;pName, const int &amp;offset, const std::string &amp;path_name, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S)</td></tr>
<tr class="memdesc:aa1c12c637c011a35f3a14b2d80daaa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a pipewrap process.  <a href="#aa1c12c637c011a35f3a14b2d80daaa61">More...</a><br /></td></tr>
<tr class="separator:aa1c12c637c011a35f3a14b2d80daaa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad00955a28146f3788186c67ec0810f"><td class="memTemplParams" colspan="2">template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If&gt; </td></tr>
<tr class="memitem:a1ad00955a28146f3788186c67ec0810f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classForSyDe_1_1SY_1_1pipewrap2.html">pipewrap2</a>&lt; T0, T1, T2 &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceForSyDe_1_1SY.html#a1ad00955a28146f3788186c67ec0810f">make_pipewrap2</a> (const std::string &amp;pName, const int &amp;offset, const std::string &amp;path_name, OIf&lt; T0 &gt; &amp;outS, I1If&lt; T1 &gt; &amp;inp1S, I2If&lt; T2 &gt; &amp;inp2S)</td></tr>
<tr class="memdesc:a1ad00955a28146f3788186c67ec0810f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to construct a pipewrap process.  <a href="#a1ad00955a28146f3788186c67ec0810f">More...</a><br /></td></tr>
<tr class="separator:a1ad00955a28146f3788186c67ec0810f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for synchronous MoC. </p>
<p>This namespace includes constructs used for building models in the synchronous MoC. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afb63d4692c64b3f67c21bc08a7a013b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, template&lt; class &gt; class FIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1apply.html">apply</a>&lt;T0,T1&gt;* ForSyDe::SY::make_apply </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIf&lt; typename <a class="el" href="classForSyDe_1_1SY_1_1apply.html">apply</a>&lt; T0, T1 &gt;::functype &gt; &amp;&#160;</td>
          <td class="paramname"><em>fS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a comb process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a87d770d2ccab943683243a0de966f89c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1comb.html">comb</a>&lt;T0,T1&gt;* ForSyDe::SY::make_comb </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1comb.html">comb</a>&lt; T0, T1 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a comb process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="aa61b15d0c27d677b99ad63f05373be50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1comb2.html">comb2</a>&lt;T0,T1,T2&gt;* ForSyDe::SY::make_comb2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1comb2.html">comb2</a>&lt; T0, T1, T2 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1comb2.html" title="Process constructor for a combinational process with two inputs and one output. ">comb2</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a46975052ec2025ddf543b98ce7d664a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1comb3.html">comb3</a>&lt;T0,T1,T2,T3&gt;* ForSyDe::SY::make_comb3 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1comb3.html">comb3</a>&lt; T0, T1, T2, T3 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I3If&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp3S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1comb3.html" title="Process constructor for a combinational process with three inputs and one output. ...">comb3</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a1daf479d32ff8fd32adf05eb72d00389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If, class T4 , template&lt; class &gt; class I4If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1comb4.html">comb4</a>&lt;T0,T1,T2,T3,T4&gt;* ForSyDe::SY::make_comb4 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1comb4.html">comb4</a>&lt; T0, T1, T2, T3, T4 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I3If&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp3S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I4If&lt; T4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp4S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1comb4.html" title="Process constructor for a combinational process with four inputs and one output. ">comb4</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a6c9f288c9dce4acfba5a4a112059c99a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1combX.html">combX</a>&lt;T0,T1,N&gt;* ForSyDe::SY::make_combX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1combX.html">combX</a>&lt; T0, T1, N &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IIf&lt; T1 &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1combX.html" title="Process constructor for a combinational process with an array of inputs and one output. ">combX</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ab639431eaf8ef9f08a5fb8c168b62e49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1constant.html">constant</a>&lt;T&gt;* ForSyDe::SY::make_constant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a constant source process. </p>
<p>This function is used to construct a constant (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a54e824696a2205f8391f4b6cf01111e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1delay.html">delay</a>&lt;T&gt;* ForSyDe::SY::make_delay </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a delay process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ade590b304bcdded02c2ebdab9e3ac32b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1delayn.html">delayn</a>&lt;T&gt;* ForSyDe::SY::make_delayn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a delayn process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="aa87376d15c9eb8416a17eb227529f0fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1fanout.html">fanout</a>&lt;T&gt;* ForSyDe::SY::make_fanout </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a fanout process. </p>
<p>This function is used to construct a fanout process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a2b5edc3da212b9904eec309e5fed1d99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class IIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1file__sink.html">file_sink</a>&lt;T&gt;* ForSyDe::SY::make_file_sink </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1SY_1_1file__sink.html">file_sink</a>&lt; T &gt;::functype&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1file__sink.html" title="Process constructor for a file_sink process. ">file_sink</a> process. </p>
<p>This function is used to construct a <a class="el" href="classForSyDe_1_1SY_1_1file__sink.html" title="Process constructor for a file_sink process. ">file_sink</a> (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="ae0339bebf674166d86b372308ab009f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1file__source.html">file_source</a>&lt;T&gt;* ForSyDe::SY::make_file_source </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classForSyDe_1_1SY_1_1file__source.html">file_source</a>&lt; T &gt;::functype&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1file__source.html" title="Process constructor for a file_source process. ">file_source</a> process. </p>
<p>This function is used to construct a <a class="el" href="classForSyDe_1_1SY_1_1file__source.html" title="Process constructor for a file_source process. ">file_source</a> (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a8ab69eb1bb9e05accb50680f02b74618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1fill.html">fill</a>&lt;T&gt;* ForSyDe::SY::make_fill </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a fill process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a7329f62457a853719bface871f35b736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1gaussian.html">gaussian</a>* ForSyDe::SY::make_gaussian </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>gaussVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>gaussMean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a Gaussian randome wave generator. </p>
<p>This function is used to construct a Gaussian (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gaussVar</td><td>The variance </td></tr>
    <tr><td class="paramname">gaussMean</td><td>The mean value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa3801c2e6def022c4bce6d83279b831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1gdbwrap.html">gdbwrap</a>&lt;T0,T1&gt;* ForSyDe::SY::make_gdbwrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>exec_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a gdbwrap process. </p>
<p>This function is used to construct a GDB wrapper process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a3b7fca57669172abf2a71ace5b22d2dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1group.html">group</a>&lt;T&gt;* ForSyDe::SY::make_group </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::vector&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a group process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a0eec84602a91ad67b2116a7c3bfd7afb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1hold.html">hold</a>&lt;T&gt;* ForSyDe::SY::make_hold </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a hold process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="abf66281dab2362f99fee2bfac9e6a986"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a>&lt;IT,ST,OT&gt;* ForSyDe::SY::make_mealy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a>&lt; IT, ST, OT &gt;::ns_functype &amp;&#160;</td>
          <td class="paramname"><em>_ns_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1mealy.html">mealy</a>&lt; IT, ST, OT &gt;::od_functype &amp;&#160;</td>
          <td class="paramname"><em>_od_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST &amp;&#160;</td>
          <td class="paramname"><em>init_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; OT &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; IT &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a mealy process. </p>
<p>This function is used to construct a mealy process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a7e583babb654a0c8239aee156f55c48f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a>&lt;IT,ST,OT&gt;* ForSyDe::SY::make_moore </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a>&lt; IT, ST, OT &gt;::ns_functype &amp;&#160;</td>
          <td class="paramname"><em>_ns_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1moore.html">moore</a>&lt; IT, ST, OT &gt;::od_functype &amp;&#160;</td>
          <td class="paramname"><em>_od_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST &amp;&#160;</td>
          <td class="paramname"><em>init_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; OT &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; IT &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a moore process. </p>
<p>This function is used to construct a moore process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="aa1c12c637c011a35f3a14b2d80daaa61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1pipewrap.html">pipewrap</a>&lt;T0,T1&gt;* ForSyDe::SY::make_pipewrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a pipewrap process. </p>
<p>This function is used to construct a pipe wrapper process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a1ad00955a28146f3788186c67ec0810f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1pipewrap2.html">pipewrap2</a>&lt;T0,T1,T2&gt;* ForSyDe::SY::make_pipewrap2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a pipewrap process. </p>
<p>This function is used to construct a pipe wrapper process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="addbf212ac85c54c4ddb5e89b8889e65b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1receiver.html">receiver</a>&lt;T0&gt;* ForSyDe::SY::make_receiver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sender process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>MPI rank of the source process </td></tr>
    <tr><td class="paramname">tag</td><td>MPI tag of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a4aea80c3de01819bcf03cf42cce669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1scomb.html">scomb</a>&lt;T0,T1&gt;* ForSyDe::SY::make_scomb </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb.html">scomb</a>&lt; T0, T1 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict comb process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a59a94af6584aabda25ff033f6c707c70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1scomb2.html">scomb2</a>&lt;T0,T1,T2&gt;* ForSyDe::SY::make_scomb2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb2.html">scomb2</a>&lt; T0, T1, T2 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1comb2.html" title="Process constructor for a combinational process with two inputs and one output. ">comb2</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a85d7f3aab5a03a118df8df3bc7bed19e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1scomb3.html">scomb3</a>&lt;T0,T1,T2,T3&gt;* ForSyDe::SY::make_scomb3 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb3.html">scomb3</a>&lt; T0, T1, T2, T3 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I3If&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp3S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1comb3.html" title="Process constructor for a combinational process with three inputs and one output. ...">comb3</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="aea403a33546132f38f3b1456d82964c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, class T3 , template&lt; class &gt; class I3If, class T4 , template&lt; class &gt; class I4If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1scomb4.html">scomb4</a>&lt;T0,T1,T2,T3,T4&gt;* ForSyDe::SY::make_scomb4 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1scomb4.html">scomb4</a>&lt; T0, T1, T2, T3, T4 &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I3If&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp3S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I4If&lt; T4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp4S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1comb4.html" title="Process constructor for a combinational process with four inputs and one output. ">comb4</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ae5a494588228c52f760a86f645e44e77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1scombX.html">scombX</a>&lt;T0,T1,N&gt;* ForSyDe::SY::make_scombX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1scombX.html">scombX</a>&lt; T0, T1, N &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; IIf&lt; T1 &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1combX.html" title="Process constructor for a combinational process with an array of inputs and one output. ">combX</a> process. </p>
<p>This function is used to construct a process (SystemC module) and connect its input and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ada1fe7a287569dd72f7bcb8d1d6353fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sconstant.html">sconstant</a>&lt;T&gt;* ForSyDe::SY::make_sconstant </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict constant source process. </p>
<p>This function is used to construct a constant (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a4790f7fa7967c91d3c7739bc09ee3739"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sdelay.html">sdelay</a>&lt;T&gt;* ForSyDe::SY::make_sdelay </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict delay process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a7792c329909728bede11cb8333f9ca9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sdelayn.html">sdelayn</a>&lt;T&gt;* ForSyDe::SY::make_sdelayn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict delayn process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a40b9bc0bf4ec7050c53ca1fec0776abf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sdpmap.html">sdpmap</a>&lt;T0,T1,N&gt;* ForSyDe::SY::make_sdpmap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1sdpmap.html">sdpmap</a>&lt; T0, T1, N &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::array&lt; T0, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::array&lt; T1, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict data parallel comb process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ad8a86f91a11fc08f9c65db17b34b7203"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, template&lt; class &gt; class IIf, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sdpreduce.html">sdpreduce</a>&lt;T0,N&gt;* ForSyDe::SY::make_sdpreduce </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1sdpreduce.html">sdpreduce</a>&lt; T0, N &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::array&lt; T0, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict reduce process. </p>
<p>This function is used to construct a sreduce process (SystemC module) and connect connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a608f1c2f13be19bdbdb0a6523543735d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class OIf, class T1 , template&lt; class &gt; class IIf, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sdpscan.html">sdpscan</a>&lt;T0,T1,N&gt;* ForSyDe::SY::make_sdpscan </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1sdpscan.html">sdpscan</a>&lt; T0, T1, N &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T0 &amp;&#160;</td>
          <td class="paramname"><em>init_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::array&lt; T0, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::array&lt; T1, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict data parallel scan process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ae5a310646284bf8f390ed5f04e317001"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T0 , template&lt; class &gt; class I0If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sender.html">sender</a>&lt;T0&gt;* ForSyDe::SY::make_sender </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I0If&lt; T0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sender process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>MPI rank of the destination process </td></tr>
    <tr><td class="paramname">tag</td><td>MPI tag of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c759e4614db2279402d6d8cb372caa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sgroup.html">sgroup</a>&lt;T&gt;* ForSyDe::SY::make_sgroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict group process. </p>
<p>This function is used to construct a process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a3cd3ed84f9a1020af6d317efbc42e366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class IIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sink.html">sink</a>&lt;T&gt;* ForSyDe::SY::make_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1sink.html">sink</a>&lt; T &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sink process. </p>
<p>This function is used to construct a sink (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a37c7f3c4dddee63bf8e9b0dbd0e5a3d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a>&lt;IT,ST,OT&gt;* ForSyDe::SY::make_smealy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a>&lt; IT, ST, OT &gt;::ns_functype &amp;&#160;</td>
          <td class="paramname"><em>_ns_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1smealy.html">smealy</a>&lt; IT, ST, OT &gt;::od_functype &amp;&#160;</td>
          <td class="paramname"><em>_od_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST &amp;&#160;</td>
          <td class="paramname"><em>init_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; OT &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; IT &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict mealy process. </p>
<p>This function is used to construct a mealy process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ab0183e954d89a20dc36c9f5ceb16581d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT , typename ST , typename OT , template&lt; class &gt; class IIf, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a>&lt;IT,ST,OT&gt;* ForSyDe::SY::make_smoore </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a>&lt; IT, ST, OT &gt;::ns_functype &amp;&#160;</td>
          <td class="paramname"><em>_ns_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1smoore.html">smoore</a>&lt; IT, ST, OT &gt;::od_functype &amp;&#160;</td>
          <td class="paramname"><em>_od_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST &amp;&#160;</td>
          <td class="paramname"><em>init_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; OT &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; IT &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a moore process. </p>
<p>This function is used to construct a moore process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input and output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a7fe96091c397991785ff3d4db4d10595"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1source.html">source</a>&lt;T&gt;* ForSyDe::SY::make_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1source.html">source</a>&lt; T &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a source process. </p>
<p>This function is used to construct a source (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="ab64ca16ee881123f9453e7f57ad55f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class IIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1ssink.html">ssink</a>&lt;T&gt;* ForSyDe::SY::make_ssink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1ssink.html">ssink</a>&lt; T &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>inS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict sink process. </p>
<p>This function is used to construct a sink (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a4615aef7b6f79ee081fc853c1da53f43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1ssource.html">ssource</a>&lt;T&gt;* ForSyDe::SY::make_ssource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classForSyDe_1_1SY_1_1ssource.html">ssource</a>&lt; T &gt;::functype &amp;&#160;</td>
          <td class="paramname"><em>_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict source process. </p>
<p>This function is used to construct a source (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="afb225ef58122f33eb0559524ab6da2d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class IIf, class T1 , template&lt; class &gt; class O1If, class T2 , template&lt; class &gt; class O2If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1sunzip.html">sunzip</a>&lt;T1,T2&gt;* ForSyDe::SY::make_sunzip </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::tuple&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a sunzip process. </p>
<p>This function is used to construct a strict unzip process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a7e86cf0df2275d2c805c16dba6cda19f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1svsource.html">svsource</a>&lt;T&gt;* ForSyDe::SY::make_svsource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict vector source process. </p>
<p>This function is used to construct a vector source (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a42aebb572d0be25950ae16730c9111da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1szip.html">szip</a>&lt;T1,T2&gt;* ForSyDe::SY::make_szip </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::tuple&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a szip process. </p>
<p>This function is used to construct a strict zip process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a9d5553e0a09825433d644b15b351a37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , std::size_t N, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1szipX.html">szipX</a>&lt;T1,N&gt;* ForSyDe::SY::make_szipX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::array&lt; T1, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1szipX.html" title="The strict zipX process with an array of inputs and one output. ">szipX</a> process. </p>
<p>This function is used to construct a szip process (SystemC module) and connect its output signal. The user binds the inputs manually. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a4fb297a58cbb9fb20dc48337bc82af29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class IIf, class T1 , template&lt; class &gt; class O1If, class T2 , template&lt; class &gt; class O2If&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1unzip.html">unzip</a>&lt;T1,T2&gt;* ForSyDe::SY::make_unzip </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::tuple&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T2 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct an unzip process. </p>
<p>This function is used to construct an unzip process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a7b046ecbb1e601af916ab688243950fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class IIf, class T1 , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1unzipX.html">unzipX</a>&lt;T1,N&gt;* ForSyDe::SY::make_unzipX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::array&lt; T1, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process. </p>
<p>This function is used to construct a strict <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process (SystemC module) and connect its input signal. The user binds the outputs manually. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a231edbef798b2e0d6aa1b722e716fd7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class IIf, class T1 , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1unzipX.html">unzipX</a>&lt;T1,N&gt;* ForSyDe::SY::make_unzipX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IIf&lt; std::array&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>inpS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct an <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process. </p>
<p>This function is used to construct an <a class="el" href="classForSyDe_1_1SY_1_1unzipX.html" title="The unzipX process with one input and an array of outputs. ">unzipX</a> process (SystemC module) and connect its input signal. The user binds the outputs manually. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a040747a75c27e56d6816377a2e817b44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1vsource.html">vsource</a>&lt;T&gt;* ForSyDe::SY::make_vsource </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a vector source process. </p>
<p>This function is used to construct a vector source (SystemC module) and connect its output signal. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the output FIFOs. </p>

</div>
</div>
<a class="anchor" id="a9f502bb45bc4e38fda5f5cff37a26d3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , template&lt; class &gt; class I1If, class T2 , template&lt; class &gt; class I2If, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1zip.html">zip</a>&lt;T1,T2&gt;* ForSyDe::SY::make_zip </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::tuple&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T2 &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1If&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp1S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2If&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inp2S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a zip process. </p>
<p>This function is used to construct a zip process (SystemC module) and connect its output and output signals. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
<a class="anchor" id="a1a9bf797bccc439af4fa252ffd7563bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , std::size_t N, template&lt; class &gt; class OIf&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classForSyDe_1_1SY_1_1zipX.html">zipX</a>&lt;T1,N&gt;* ForSyDe::SY::make_zipX </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OIf&lt; std::array&lt; <a class="el" href="classForSyDe_1_1abst__ext.html">abst_ext</a>&lt; T1 &gt;, N &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to construct a <a class="el" href="classForSyDe_1_1SY_1_1zipX.html" title="The zipX process with an array of inputs and one output. ">zipX</a> process. </p>
<p>This function is used to construct a zip process (SystemC module) and connect its output signals. The user binds the inputs manually. It provides a more functional style definition of a <a class="el" href="namespaceForSyDe.html" title="The namespace for ForSyDe. ">ForSyDe</a> process. It also removes bilerplate code by using type-inference feature of C++ and automatic binding to the input FIFOs. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
Doxygen
</a> 1.8.11
</small></address>
</body>
</html>
