/*
 * Copyright QTronic GmbH. All rights reserved.
 */

/* ---------------------------------------------------------------------------*
 * XmlParser.h
 * Parser for xml model description file of a FMI 2.0 model.
 * The result of parsing is a ModelDescription object that can be queried to
 * get necessary information. The parsing is based on libxml2.lib.
 *
 * Author: Adrian Tirea
 * ---------------------------------------------------------------------------*/

#ifndef XML_PARSER_H
#define XML_PARSER_H

#include <libxml/xmlreader.h>

#ifdef _MSC_VER
#pragma comment(lib, "libxml2.lib")
#pragma comment(lib, "wsock32.lib")
#endif

#include <utility>
#include <vector>
#include "XmlElement.h"
#include "XmlParserException.h"
#include <cstring> // strdup()

#ifdef STANDALONE_XML_PARSER
#define logThis(n, ...) printf(__VA_ARGS__); printf("\n")
#define checkStrdup(str) strdup(str)
#else
#include "GlobalIncludes.h"
#include "logging.h"  // logThis
#include "minutil.h"  // checkStrdup
#endif  // STANDALONE_XML_PARSER

#ifndef fmi2TypesPlatform_h
// same as in FMI 2.0 specification
typedef unsigned int fmi2ValueReference;
#endif

class Element;
class ModelDescription;

class XmlParser {
 public:
    // Elements
    static const int SIZEOF_ELM = 31;
    static const char *elmNames[SIZEOF_ELM];
    enum Elm {
        elm_BAD_DEFINED = -1,
        elm_fmiModelDescription, elm_ModelExchange, elm_CoSimulation, elm_SourceFiles, elm_File,
        elm_UnitDefinitions, elm_Unit, elm_BaseUnit, elm_DisplayUnit, elm_TypeDefinitions,
        elm_SimpleType, elm_Real, elm_Integer, elm_Boolean, elm_String,
        elm_Enumeration, elm_Item, elm_LogCategories, elm_Category, elm_DefaultExperiment,
        elm_VendorAnnotations, elm_Tool, elm_ModelVariables, elm_ScalarVariable, elm_Annotations,
        elm_ModelStructure, elm_Outputs, elm_Derivatives, elm_DiscreteStates, elm_InitialUnknowns,
        elm_Unknown
    };

    // Attributes
    static const int SIZEOF_ATT = 64;  // 61;
    static const char *attNames[SIZEOF_ATT];
    enum Att {
        att_BAD_DEFINED = -1,
        att_fmiVersion, att_modelName, att_guid, att_description, att_author,
        att_version, att_copyright, att_license, att_generationTool, att_generationDateAndTime,
        att_variableNamingConvention, att_numberOfEventIndicators, att_name, att_kg, att_m,
        att_s, att_A, att_K, att_mol, att_cd,
        att_rad, att_factor, att_offset, att_quantity, att_unit,
        att_displayUnit, att_relativeQuantity, att_min, att_max, att_nominal,
        att_unbounded, att_value, att_startTime, att_stopTime, att_tolerance,
        att_stepSize, att_valueReference, att_causality, att_variability, att_initial,
        att_previous, att_canHandleMultipleSetPerTimeInstant, att_declaredType, att_start, att_derivative,
        att_reinit, att_index, att_dependencies, att_dependenciesKind, att_modelIdentifier,
        att_needsExecutionTool, att_completedIntegratorStepNotNeeded, att_canBeInstantiatedOnlyOncePerProcess,
            att_canNotUseMemoryManagementFunctions, att_canGetAndSetFMUstate,
        att_canSerializeFMUstate, att_providesDirectionalDerivative, att_canHandleVariableCommunicationStepSize,
            att_canInterpolateInputs, att_maxOutputDerivativeOrder,
        att_canRunAsynchronuously,

        att_xmlnsXsi, att_providesDirectionalDerivatives, att_canHandleEvents
    };

    // Enumeration values
    static const int SIZEOF_ENU = 17;
    static const char *enuNames[SIZEOF_ENU];
    enum Enu {
        enu_BAD_DEFINED = -1,
        enu_flat, enu_structured, enu_dependent, enu_constant, enu_fixed,
        enu_tunable, enu_discrete, enu_parameter, enu_calculatedParameter, enu_input,
        enu_output, enu_local, enu_independent, enu_continuous, enu_exact,
        enu_approx, enu_calculated
    };

    // Possible results when retrieving an attribute value from an element
    enum ValueStatus {
        valueMissing,
        valueDefined,
        valueIllegal
    };

 private:
    char *xmlPath;
    xmlTextReaderPtr xmlReader;

 public:
    // return the type of this element. Int value match the index in elmNames.
    // throw XmlParserException if element is invalid.
    static XmlParser::Elm checkElement(const char* elm);
    // return the type of this attribute. Int value match the index in attNames.
    // throw XmlParserException if attribute is invalid.
    static XmlParser::Att checkAttribute(const char* att);
    // return the type of this enum value. Int value match the index in enuNames.
    // throw XmlParserException if enu is invalid.
    static XmlParser::Enu checkEnumValue(const char* enu);

    explicit XmlParser(char *xmlPath);
    ~XmlParser();
    // return NULL on errors. Caller must free the result if not NULL.
    ModelDescription *parse();

    // throw XmlParserException if attribute invalid.
    void parseElementAttributes(Element *element);
    void parseChildElements(Element *el);
    void parseEndElement();
    void parseSkipChildElement();

 private:
    // advance reading in xml and skip comments if present.
    bool readNextInXml();

    // check some properties of model description (i.e. each variable has valueReference, ...)
    // if valid return the input model description, else return NULL.
    ModelDescription *validate(ModelDescription *md);
};

const char *XmlParser::elmNames[SIZEOF_ELM] = {
    "fmiModelDescription", "ModelExchange", "CoSimulation", "SourceFiles", "File",
    "UnitDefinitions", "Unit", "BaseUnit", "DisplayUnit", "TypeDefinitions",
    "SimpleType", "Real", "Integer", "Boolean", "String",
    "Enumeration", "Item", "LogCategories", "Category", "DefaultExperiment",
    "VendorAnnotations", "Tool", "ModelVariables", "ScalarVariable", "Annotations",
    "ModelStructure", "Outputs", "Derivatives", "DiscreteStates", "InitialUnknowns",
    "Unknown"
};

const char *XmlParser::attNames[SIZEOF_ATT] = {
    "fmiVersion", "modelName", "guid", "description", "author",
    "version", "copyright", "license", "generationTool", "generationDateAndTime",
    "variableNamingConvention", "numberOfEventIndicators", "name", "kg", "m",
    "s", "A", "K", "mol", "cd",
    "rad", "factor", "offset", "quantity", "unit",
    "displayUnit", "relativeQuantity", "min", "max", "nominal",
    "unbounded", "value", "startTime", "stopTime", "tolerance",
    "stepSize", "valueReference", "causality", "variability", "initial",
    "previous", "canHandleMultipleSetPerTimeInstant", "declaredType", "start", "derivative",
    "reinit", "index", "dependencies", "dependenciesKind", "modelIdentifier",
    "needsExecutionTool", "completedIntegratorStepNotNeeded", "canBeInstantiatedOnlyOncePerProcess",
        "canNotUseMemoryManagementFunctions", "canGetAndSetFMUstate",
    "canSerializeFMUstate", "providesDirectionalDerivative", "canHandleVariableCommunicationStepSize",
        "canInterpolateInputs", "maxOutputDerivativeOrder",
    "canRunAsynchronuously",

    // not conform with the FMI 2.0 doc.  // TODO : remove when used models become mature.
    "xmlns:xsi",                       // Dymola examples from 2014 FD01
    "providesDirectionalDerivatives",  // Dymola examples from 2014 FD01
    "canHandleEvents"                  // Dymola examples from 2014 FD01
};

const char *XmlParser::enuNames[SIZEOF_ENU] = {
    "flat", "structured", "dependent", "constant", "fixed",
    "tunable", "discrete", "parameter", "calculatedParameter", "input",
    "output", "local", "independent", "continuous", "exact",
    "approx", "calculated"
};

XmlParser::XmlParser(char *xmlPath) {
    this->xmlPath = (char *)checkStrdup(xmlPath);
    xmlReader = NULL;
}

XmlParser::~XmlParser() {
    free(xmlPath);
}

ModelDescription *XmlParser::parse() {
    xmlReader = xmlReaderForFile(xmlPath, NULL, 0);
    ModelDescription *md = NULL;
    if (xmlReader != NULL) {
        try {
            if (readNextInXml()) {
                // I expect that first element is fmiModelDescription.
                if (0 != strcmp((char *)xmlTextReaderConstLocalName(xmlReader), elmNames[elm_fmiModelDescription])) {
                    throw XmlParserException("Expected '%s' element. Found instead: '%s'.",
                        elmNames[elm_fmiModelDescription],
                        xmlTextReaderConstLocalName(xmlReader));
                }

                md = new ModelDescription;
                md->type = elm_fmiModelDescription;
                parseElementAttributes((Element *)md);
                parseChildElements(md);
            } else {
                throw XmlParserException("Syntax error parsing xml file '%s'", xmlPath);
            }
        } catch (XmlParserException& e) {
            logThis(ERROR_ERROR, e.what());
            md = NULL;
        } catch (std::bad_alloc& ) {
            logThis(ERROR_FATAL, "Out of memory");
            md = NULL;
        }
        xmlFreeTextReader(xmlReader);
    } else {
        logThis(ERROR_ERROR, "Unable to open '%s'", xmlPath);
    }

    return validate(md);
}

// Returns the index of name in the array.
// Throw exception if name not found (invalid).
static int checkName(const char *name, const char *kind, const char *array[], int n) {
    for (int i = 0; i < n; i++) {
        if (!strcmp(name, array[i])) {
            return i;
        }
    }
    throw XmlParserException("Illegal %s %s", kind, name);
}

XmlParser::Att XmlParser::checkAttribute(const char *att) {
    return (XmlParser::Att)checkName(att, "attribute", XmlParser::attNames, XmlParser::SIZEOF_ATT);
}

void XmlParser::parseElementAttributes(Element *element) {
    while (xmlTextReaderMoveToNextAttribute(xmlReader)) {
        xmlChar *name = xmlTextReaderName(xmlReader);
        xmlChar *value = xmlTextReaderValue(xmlReader);
        XmlParser::Att key = checkAttribute((char *)name);
        char *theValue = value ? (char *)checkStrdup((char *)value) : NULL;
        element->attributes.insert(std::pair<XmlParser::Att, char *>(key, theValue));
        xmlFree(name);
        xmlFree(value);
    }
}

void XmlParser::parseChildElements(Element *el) {
    int elementIsEmpty = xmlTextReaderIsEmptyElement(xmlReader);
    if (elementIsEmpty == -1) {
        throw XmlParserException("Error parsing xml file '%s'", xmlPath);
    } else if (elementIsEmpty == 1) {
        return;
    }

    bool ret = readNextInXml();
    while (ret  && xmlTextReaderNodeType(xmlReader) != XML_READER_TYPE_END_ELEMENT) {
        if (xmlTextReaderNodeType(xmlReader) == XML_READER_TYPE_ELEMENT) {
            const char *localName = (char *)xmlTextReaderConstLocalName(xmlReader);
            int depthBefore = xmlTextReaderDepth(xmlReader);
            int isEmptyElement = xmlTextReaderIsEmptyElement(xmlReader);
            el->handleElement(this, localName, isEmptyElement);
            if (!isEmptyElement) {
                int depthAfter = xmlTextReaderDepth(xmlReader);
                if (depthBefore != depthAfter) {
                    throw XmlParserException("Parser error. Depth wrong after parsing sub-tree for %s.", localName);
                }
            }
        }
        ret = readNextInXml();
    }
    if (!ret) {
        throw XmlParserException("Error parsing xml file '%s'", xmlPath);
    }
}

void XmlParser::parseEndElement() {
    bool ret = readNextInXml();
    while (ret  && xmlTextReaderNodeType(xmlReader) != XML_READER_TYPE_END_ELEMENT) {
        ret = readNextInXml();
    }
    if (!ret) {
        throw XmlParserException("Error parsing xml file '%s'", xmlPath);
    }
}

void XmlParser::parseSkipChildElement() {
    int ret = xmlTextReaderNext(xmlReader);
    if (ret == -1) {
        throw XmlParserException("Error parsing xml file '%s'", xmlPath);
    }
}

bool XmlParser::readNextInXml() {
    int ret;
    do {
        ret = xmlTextReaderRead(xmlReader);
    } while (ret == 1 && xmlTextReaderNodeType(xmlReader) == XML_READER_TYPE_COMMENT);

    if (ret != 1) {
        return false;
    }
    return true;
}

/* -------------------------------------------------------------------------* 
 * Helper functions to check validity of xml.
 * -------------------------------------------------------------------------*/

XmlParser::Elm XmlParser::checkElement(const char *elm) {
    return (XmlParser::Elm)checkName(elm, "element", XmlParser::elmNames, XmlParser::SIZEOF_ELM);
}

XmlParser::Enu XmlParser::checkEnumValue(const char *enu) {
    return (XmlParser::Enu)checkName(enu, "enum value", XmlParser::enuNames, XmlParser::SIZEOF_ENU);
}

ModelDescription *XmlParser::validate(ModelDescription *md) {
    if (md == NULL) return NULL;
    int errors = 0;
    // check modelDescription required attributes
    if (!(md->getAttributeValue(XmlParser::att_fmiVersion)
        && md->getAttributeValue(XmlParser::att_modelName)
        && md->getAttributeValue(XmlParser::att_guid))) {
            logThis(ERROR_ERROR, "Model description miss required attributes in file %s", xmlPath);
            return NULL;
    }

    if (!(md->coSimulation || md->modelExchange)) {
        logThis(ERROR_ERROR, "Model description must have a co-simulation or model exchange component in file %s",
            xmlPath);
            return NULL;
    }

    // check model variables
    for (std::vector<ScalarVariable *>::const_iterator it = md->modelVariables.begin(); it != md->modelVariables.end();
            ++it) {
        const char *varName = (*it)->getAttributeValue(XmlParser::att_name);
        if (!varName) {
            logThis(ERROR_ERROR, "Scalar variable miss required %s attribute in modelDescription.xml",
                XmlParser::attNames[XmlParser::att_name]);
            errors++;
            continue;
        }
        XmlParser::ValueStatus vs;
        (*it)->getAttributeUInt(XmlParser::att_valueReference, &vs);
        if (vs == XmlParser::valueMissing) {
            logThis(ERROR_ERROR, "Scalar variable %s miss required %s attribute in modelDescription.xml",
                varName, XmlParser::attNames[XmlParser::att_valueReference]);
            errors++;
            continue;
        }
        if (vs == XmlParser::valueIllegal) {
            logThis(ERROR_ERROR, "Scalar variable %s has illegal format for %s attribute in modelDescription.xml",
                varName, XmlParser::attNames[XmlParser::att_valueReference]);
            errors++;
            continue;
        }
        if (!(*it)->typeSpec) {
            logThis(ERROR_ERROR, "Scalar variable %s miss type specification %s in modelDescription.xml",
                varName, XmlParser::attNames[XmlParser::att_valueReference]);
            errors++;
            continue;
        }
        if ((*it)->typeSpec->type == XmlParser::elm_Enumeration) {
            const char *typeName = (*it)->typeSpec->getAttributeValue(XmlParser::att_declaredType);
            if (!typeName) {
                logThis(ERROR_ERROR, "Scalar variable %s with enum type specification miss required %s attribute in "
                        "modelDescription.xml", varName, XmlParser::attNames[XmlParser::att_declaredType]);
                errors++;
                continue;
            }
            if (!md->getSimpleType(typeName)) {
                logThis(ERROR_ERROR, "Declared type %s of variable %s not found in modelDescription.xml",
                     typeName, varName);
                errors++;
                continue;
            }
        }
    }

    if (errors > 0) {
        logThis(ERROR_ERROR, "Found %d error in file %s", errors, xmlPath);
        return NULL;
    }
    return md;
}

// #define TEST
#ifdef TEST
int main() {
    // { char c='c'; while(c!='g') scanf("%c", &c); } // to debug: wait for the g key

    XmlParser *parser =
        new XmlParser("c:\\_data\\fmi-fmu\\fmi-fmuVS\\fmi-fmuVS\\modelDescriptionDymola - ManuallyModifiedCopy.xml");
    ModelDescription *md = parser->parse();
    if (md) md->printElement(0);
    delete parser;
    if (md) delete md;

    dumpMemoryLeaks();
    return 0;
}
#endif  // TEST

#endif  // XML_PARSER_H
